---
tags:
  - ComptuerScience/동시성
  - 병렬성
  - JavaScript
Habitus:
  - "[[◦ Knowledge]]"
  - "[[◦ Linguistic]]"
  - "[[◦ Social]]"
up:
  - "[[Concurrency Vs Parallelism]]"
---
## 동시성 (Concurrency)

동시성은 여러 작업이 **논리적으로** 동시에 진행되는 것을 의미합니다. JavaScript에서는 단일 스레드로 동작하지만, **이벤트 루프**를 통해 동시성을 구현합니다.

### 비유: 믹싱 콘솔에서의 여러 트랙 관리

**라이브 공연 중 사운드 엔지니어는 믹싱 콘솔을 통해 여러 악기와 보컬의 소리를 조절합니다. 하지만 두 손으로 한 번에 하나의 노브(knob)나 페이더(fader)만 조작할 수 있습니다.** 그럼에도 불구하고 빠르게 여러 컨트롤을 번갈아 가며 조작하여 전체적인 사운드를 조화롭게 유지합니다.

- 여기서 **사운드 엔지니어가 여러 트랙을 관리하는 것**은 **JavaScript의 동시성**에 해당합니다.
- **각각의 노브 조작**은 **단일 스레드의 작업**이고, 이를 빠르게 번갈아 가며 조작하는 것은 **비동기 작업 처리**입니다.

### 이벤트 루프

- **이벤트 루프(Event Loop)** 는 JavaScript에서 비동기 작업을 관리하는 메커니즘입니다.
- 이는 **사운드 엔지니어가 대기 중인 여러 사운드 조정 요청을 순서대로 처리하는 것**과 비슷합니다.
- 긴급한 조정은 우선 처리하고, 나머지는 차례로 처리하여 공연의 흐름을 매끄럽게 유지합니다.

**예시 코드:**

```javascript
console.log("공연 시작");

setTimeout(() => console.log("리버브 적용"), 0);
setTimeout(() => console.log("디스토션 적용"), 0);

Promise.resolve().then(() => console.log("볼륨 조정 1"));
Promise.resolve().then(() => console.log("볼륨 조정 2"));

console.log("공연 진행 중");
```

**실행 결과:**

```
공연 시작
공연 진행 중
볼륨 조정 1
볼륨 조정 2
리버브 적용
디스토션 적용
```

**설명:**

- **볼륨 조정(Promise)** 은 즉각적으로 필요한 작업이므로 먼저 처리됩니다.
- **이펙트 적용(setTimeout)** 은 조금 뒤에 처리해도 되므로 나중에 실행됩니다.
- 이는 **사운드 엔지니어가 긴급한 볼륨 조정을 먼저 하고, 이후에 이펙트 적용을 수행하는 것**과 같습니다.

---

## 병렬성 (Parallelism)

병렬성은 여러 작업이 **물리적으로** 동시에 진행되는 것을 의미합니다. JavaScript에서는 **Web Workers**를 통해 제한적인 병렬 처리가 가능합니다.

### 비유: 메인 엔지니어와 어시스턴트의 협업

**대형 공연에서 사운드 엔지니어는 모든 작업을 혼자 처리하기 어렵기 때문에 어시스턴트 엔지니어와 함께 작업합니다.**

- **메인 엔지니어**는 전체 믹스를 관리하고, **어시스턴트 엔지니어**는 특정 악기의 이펙트나 모니터링을 담당합니다.
- 두 엔지니어는 동시에 작업하며, 필요한 경우 서로 통신하여 공연의 음향을 최적화합니다.

여기서:

- **메인 엔지니어**는 **메인 스레드**에 해당합니다.
- **어시스턴트 엔지니어**는 **Web Worker**에 해당합니다.
- 서로 독립적으로 작업하지만, **메시지(통신)**를 통해 협업합니다.

### Web Workers의 작동 방식

- Web Worker는 **메인 스레드와 분리된 실행 환경**에서 동작하는 스레드입니다.
- **CPU 집약적인 작업**을 별도로 처리하여 메인 스레드의 응답성을 유지합니다.
- **메시지 전달**을 통해 메인 스레드와 데이터를 주고받습니다.

**예시 코드:**

*main.js*

```javascript
console.log("메인 엔지니어 작업 시작");

const worker = new Worker('worker.js');

worker.onmessage = function(event) {
  console.log('어시스턴트로부터 받은 결과:', event.data);
};

worker.postMessage('이펙트 처리 요청');

console.log("메인 엔지니어 작업 계속 진행");
```

*worker.js*

```javascript
self.onmessage = function(event) {
  console.log('어시스턴트가 받은 메시지:', event.data);
  // 복잡한 이펙트 처리 시뮬레이션
  const result = '이펙트 처리 완료';
  self.postMessage(result);
};
```

**실행 결과:**

```
메인 엔지니어 작업 시작
메인 엔지니어 작업 계속 진행
어시스턴트가 받은 메시지: 이펙트 처리 요청
어시스턴트로부터 받은 결과: 이펙트 처리 완료
```

**설명:**

- 메인 엔지니어는 자신의 작업을 계속하면서 어시스턴트에게 특정 작업을 맡깁니다.
- 어시스턴트 엔지니어는 받은 요청을 처리하고 결과를 메인 엔지니어에게 전달합니다.
- 이를 통해 **동시에** 여러 작업이 진행되어 공연의 품질을 높입니다.

---

## 정리

- **동시성 (Concurrency)**
  - JavaScript의 **이벤트 루프**를 통한 비동기 작업 처리
  - **사운드 엔지니어가 여러 트랙을 빠르게 조절하여 동시에 진행되는 것처럼 보이게 함**
  - 단일 스레드에서 여러 작업을 효율적으로 관리

- **병렬성 (Parallelism)**
  - **Web Workers**를 통한 제한적인 병렬 처리
  - **어시스턴트 엔지니어와 메인 엔지니어가 동시에 작업을 수행**
  - CPU 집약적인 작업을 메인 스레드의 방해 없이 처리 가능
