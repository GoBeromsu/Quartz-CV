{"2시간마다-한글-키보드를-자동으로-삭제하기":{"title":"2시간마다 한글 키보드를 자동으로 삭제하기","links":["크론탭(Crontab)"],"tags":["Technology","Productivity","LanguageLearning"],"content":"2시간마다 한글 키보드를 자동으로 삭제하기\n저는 영어 실력 향상을 목표로, 의도적으로 한글 사용 빈도를 줄이는 환경을 만들고자 했습니다. 한글을 계속 사용하다 보면 무의식적으로 한글을 더 자주 쓰게 되는데, 이를 방지하기 위해 2시간에 한 번씩 한글 키보드 레이아웃을 자동으로 제거하도록 설정했습니다. 이렇게 하면 한글을 다시 설정하는 번거로움이 생기기 때문에, 자연스럽게 영어만 사용하도록 유도할 수 있습니다. 이는 단순한 의지력에 의존하는 대신, 환경을 재구성하여 목표를 달성하는 구조적 개선 방법 중 하나입니다.\n설정 방법\n\n크론탭(Crontab) 설정을 통해 2시간마다 한 번씩 자동으로 한글 키보드 레이아웃이 삭제되도록 설정합니다.\n이를 통해 사용자는 자연스럽게 한글을 사용하기 어렵게 되고, 그 결과 영어 사용 빈도가 증가하게 됩니다.\n\n설정 코드\n\n\nCrontab 파일 열기:\ncrontab -e\n\n\nCrontab에 명령 추가:\n다음 코드를 추가하여, 2시간마다 한글 레이아웃을 삭제하고 영어 레이아웃만 남기도록 설정합니다.\n0 */2 * * * defaults write com.apple.HIToolbox AppleEnabledInputSources -array &#039;&lt;dict&gt;&lt;key&gt;InputSourceKind&lt;/key&gt;&lt;string&gt;Keyboard Layout&lt;/string&gt;&lt;key&gt;KeyboardLayout ID&lt;/key&gt;&lt;integer&gt;0&lt;/integer&gt;&lt;key&gt;KeyboardLayout Name&lt;/key&gt;&lt;string&gt;ABC&lt;/string&gt;&lt;/dict&gt;&#039; &amp;&amp; killall SystemUIServer\n\n\nCrontab 스케줄 확인:\n명령어가 잘 등록되었는지 확인하려면, 다음을 입력합니다:\ncrontab -l\n\n\n결과\ncrontab -l 명령어를 입력한 결과는 다음과 같습니다:\n❯ crontab -l\n \n0 */2 * * * defaults write com.apple.HIToolbox AppleEnabledInputSources -array &#039;&lt;dict&gt;&lt;key&gt;InputSourceKind&lt;/key&gt;&lt;string&gt;Keyboard Layout&lt;/string&gt;&lt;key&gt;KeyboardLayout ID&lt;/key&gt;&lt;integer&gt;0&lt;/integer&gt;&lt;key&gt;KeyboardLayout Name&lt;/key&gt;&lt;string&gt;ABC&lt;/string&gt;&lt;/dict&gt;&#039; &amp;&amp; killall SystemUIServer\n이 설정은 2시간마다 한 번씩 한글 키보드 레이아웃을 삭제하고, 시스템을 즉시 업데이트하여 영어(ABC) 레이아웃만 사용되도록 만듭니다.\n적용 후 확인\n명령이 정상적으로 실행되고 난 후, 현재 설정된 키보드 레이아웃을 확인하고 싶다면 다음 명령어를 입력하여 확인할 수 있습니다:\ndefaults read com.apple.HIToolbox AppleEnabledInputSources\n이 명령어를 통해, 현재 활성화된 키보드 레이아웃이 어떻게 설정되었는지를 확인할 수 있습니다.\n이 방식으로 한글을 자동으로 삭제함으로써, 사용자는 영어에 더 집중하게 되며, 의도적으로 영어를 많이 사용하게 될 것입니다."},"Concurrency-Vs-Parallelism":{"title":"Concurrency Vs Parallelism","links":[],"tags":[],"content":"동시성 (Concurrency)\n동시성은 JavaScript에서 비동기 프로그래밍을≤ 통해 구현됩니다. 단일 스레드 언어인 JavaScript는 이벤트 루프를 사용하여 여러 작업을 효율적으로 처리할 수 있습니다.\n이벤트 루프\n\n이벤트 루프(Event Loop) 는 프로그램 주위를 도는 큰 루프로 생각할 수 있습니다. 처리할 일이 없을 때는 멈춰있다가, 이벤트가 발생하면 해당 이벤트를 큐에 추가하고 하나씩 코드를 실행합니다.\n\n예를 들어:\nconsole.log(&quot;시작&quot;);\n \nsetTimeout(() =&gt; console.log(&quot;타이머 1&quot;), 0);\nsetTimeout(() =&gt; console.log(&quot;타이머 2&quot;), 0);\n \nPromise.resolve().then(() =&gt; console.log(&quot;프로미스 1&quot;));\nPromise.resolve().then(() =&gt; console.log(&quot;프로미스 2&quot;));\n \nconsole.log(&quot;끝&quot;);\n실행 결과:\n시작\n끝\n프로미스 1\n프로미스 2\n타이머 1\n타이머 2\n\n이 예제는 동기 코드, 마이크로태스크(Promise), 매크로태스크(setTimeout)의 실행 순서를 보여줍니다.\n비동기 함수\nES6부터 도입된 async/await 문법을 사용하면 비동기 코드를 마치 동기 코드처럼 작성할 수 있습니다. 이는 코드를 더 읽기 쉽게 만들어 줍니다.\n예를 들어:\nasync function fetchUserData(userId) {\n  try {\n    const response = await fetch(`api.example.com/users/${userId}`);\n    const userData = await response.json();\n    console.log(userData);\n  } catch (error) {\n    console.error(&quot;사용자 데이터를 가져오는 데 실패했습니다:&quot;, error);\n  }\n}\n \nfetchUserData(123);\n이 함수는 사용자 데이터를 비동기적으로 가져오면서도, 동기 코드처럼 읽히도록 작성되었습니다.\n\n병렬성 (Parallelism)\nJavaScript는 기본적으로 단일 스레드에서 실행되지만, Web Workers를 사용하면 일부 병렬 처리가 가능합니다.\nWeb Workers\n\nWeb Worker는 메인 스크립트와 함께 실행되는 별도의 JavaScript 프로세스로, 자체적인 실행 흐름을 가집니다.\n복잡하고 시간이 오래 걸리는 작업을 백그라운드에서 실행하여 메인 스레드의 응답성을 유지할 수 있습니다.\n\n예를 들어:\nmain.js\nconst worker = new Worker(&#039;worker.js&#039;);\n \nworker.onmessage = function(event) {\n  console.log(&#039;워커로부터 받은 결과:&#039;, event.data);\n};\n \nworker.postMessage([1, 2, 3, 4, 5]);\nworker.js\nself.onmessage = function(event) {\n  const numbers = event.data;\n  const result = numbers.reduce((sum, num) =&gt; sum + num, 0);\n  self.postMessage(result);\n};\n이 예제에서 워커는 메인 스크립트와 병렬로 실행되어 배열의 합계를 계산합니다.\n\n정리\n\n\n동시성 (Concurrency)\n\nJavaScript의 이벤트 루프를 통해 구현\n비동기 프로그래밍(콜백, Promise, async/await)을 사용\n단일 스레드에서 여러 작업을 효율적으로 관리\n\n\n\n병렬성 (Parallelism)\n\nWeb Workers를 통해 제한적으로 구현 가능\n메인 스레드와 별도로 백그라운드에서 스크립트 실행\nCPU 집약적인 작업에 유용\n\n\n\nJavaScript에서는 주로 동시성을 활용하여 비동기 작업을 처리하며, 필요한 경우 Web Workers를 통해 병렬 처리를 수행합니다. 이를 통해 효율적이고 반응성 높은 웹 애플리케이션을 구축할 수 있습니다."},"Error-Handling-in-GitHub-Workflow-Extensions":{"title":"Error Handling in GitHub Workflow Extensions","links":[],"tags":["PluginExtension","ProgrammingTools","ErrorHandling","GitHubWorkflow","SoftwareDevelopment","post/medium","Git","Obsidian"],"content":"I recently created my first community plugin for Obsidian, which has basic functions for practicing pronunciation. After submitting it, I received feedback from a reviewer suggesting I change the plugin’s name because its features are more focused on the pronunciation of selected text.\nFollowing the advice, I updated the information in manifest.json, README, and the repository name. After making these changes, I submitted my pull request (PR) again but encountered an error:\nError: fatal: couldn&#039;t find remote ref refs/pull/4172/merge\nThe process &#039;/usr/bin/git&#039; failed with exit code 128\n\nI believe the error was caused by the repository name change. Even though I updated everything, the workflow still referenced the same old information:\nRepo info: goberomsu/british-pronunciation-plugin\nFound issue: Your repository does not have issues enabled. Users will not be able to report bugs and request features.\n\nFortunately, I realized what was wrong and fixed it!\nHow to Solve This Issue\nIf you’re facing a similar issue, as discussed in this forum post, here’s a simple solution:\n\nDelete the Obsidian release fork: Remove the forked repository from your GitHub account.\nFork the release again: Fork the original repository once more to your account.\nCreate a new Pull Request (PR): After making your changes, open a new PR to submit your code.\n\nThis process resets the fork, allowing you to avoid the “couldn’t find remote ref” error during validation."},"Javascript-Asynchronous-Programming":{"title":"Javascript Asynchronous Programming","links":["Strack-자료구조","Concurrency-Vs-Parallelism"],"tags":["AsynchronousProgramming","JavaScriptConcepts","EventLoop"],"content":"Asynchronous programming in JavaScript is a technique that allows the program to start potentially time-consuming tasks and continue executing other tasks without waiting for the initial task to complete.\nThis approach is essential in web development where operations like fetching data from a server, reading files, or executing time-consuming computations can block the main thread, leading to unresponsive interfaces.\nKey Concepts in Asynchronous Programming\nCallbacks\nFunctions passed as arguments to other functions to be executed after the first function has completed. For example:\nsetTimeout(() =&gt; console.log(&quot;Tick&quot;), 500);\nPromises\nObjects representing the eventual completion or failure of an asynchronous operation. They can be chained and managed more systematically than callbacks.\nlet fifteen = Promise.resolve(15);\nfifteen.then(value =&gt; console.log(`Got ${value}`));\nAsync/Await\nSyntactic sugar built on top of promises, making asynchronous code easier to write and read by allowing asynchronous code to be structured similarly to synchronous code.\nasync function example() {\n  let result = await someAsyncOperation();\n  console.log(result);\n}\nThe Event Loop\nJavaScript uses an event loop to handle asynchronous operations:\n\nThe main script runs first, often setting up callbacks for later execution.\nWhen the main script completes, the program may become idle, waiting for events.\nAs events occur (e.g., timeouts, network responses), their associated callbacks are added to a queue.\nThe event loop processes these queued callbacks one by one.\n\nThis model ensures that JavaScript remains single-threaded, executing only one piece of code at a time.\nTo better understand how JavaScript handles asynchronous operations, it’s crucial to grasp the concept of the event loop and the order in which callbacks are executed. Let’s break it down:\n\n\nThe Call Stack:\n\nJavaScript uses a call stack to keep track of where it is in the program.\nWhen a function is called, it’s added to the stack. When it returns, it’s removed from the stack.\n\n\n\nThe Event Loop:\n\nThe event loop continuously checks if the call stack is empty.\nIf it’s empty, it looks at the callback queue to see if there are any functions waiting to be executed.\n\n\n\nCallback Queue:\n\nThere are actually two types of queues: the microtask queue and the macrotask queue.\nMicrotasks (like Promise callbacks) have priority over macrotasks (like setTimeout callbacks).\n\n\n\nLet’s look at an example:\nconsole.log(&#039;Start&#039;);\n \nsetTimeout(() =&gt; {\n  console.log(&#039;Timeout (Macrotask)&#039;);\n}, 0);\n \nPromise.resolve().then(() =&gt; {\n  console.log(&#039;Promise (Microtask)&#039;);\n});\n \nconsole.log(&#039;End&#039;);\nStart\nEnd\nPromise (Microtask)\nTimeout (Macrotask)\n\n\nconsole.log(&#039;Start&#039;) is executed immediately.\nsetTimeout is encountered. Its callback is scheduled as a macrotask.\nThe Promise’s then callback is scheduled as a microtask.\nconsole.log(&#039;End&#039;) is executed immediately.\nThe call stack is now empty, so the event loop checks the microtask queue first.\nThe Promise callback (microtask) is executed, logging ‘Promise (Microtask)‘.\nThe microtask queue is now empty, so the event loop moves to the macrotask queue.\nThe setTimeout callback (macrotask) is executed, logging ‘Timeout (Macrotask)‘.\n\nKey Takeaways for Junior Developers\n\nSingle-Threaded Nature: JavaScript is single-threaded, meaning it can only do one thing at a time.\nAsynchronous Operations: Functions like setTimeout and Promises allow JavaScript to perform non-blocking operations.\nMicrotasks vs Macrotasks:\n\nMicrotasks (Promises, queueMicrotask) are processed before macrotasks (setTimeout, setInterval, I/O operations).\nThis prioritization ensures that Promise resolutions are handled as soon as possible.\n\n\nEvent Loop: It’s the mechanism that allows JavaScript to perform non-blocking operations despite being single-threaded.\n\nAsynchronous Patterns\nPromise Chaining\nPromises can be chained to handle sequences of asynchronous operations:\nfetchData()\n  .then(processData)\n  .then(saveResult)\n  .catch(handleError);\nParallel Execution\nPromise.all allows multiple asynchronous operations to run concurrently:\nPromise.all([fetchUser(), fetchPosts()])\n  .then(([user, posts]) =&gt; {\n    // Use user and posts data\n  });\nAsync Functions\nAsync functions provide a cleaner syntax for working with promises:\nasync function fetchUserData() {\n  try {\n    let user = await fetchUser();\n    let posts = await fetchPosts(user.id);\n    return { user, posts };\n  } catch (error) {\n    console.error(&quot;Error fetching user data:&quot;, error);\n  }\n}\nCommon Pitfalls\n\nCallback Hell: Nesting multiple callbacks can lead to unreadable and hard-to-maintain code.\nForgetting to handle errors in asynchronous code.\nMisunderstanding the asynchronous nature of operations, leading to race conditions or unexpected behavior.\n\nBest Practices\n\nUse promises or async/await instead of nested callbacks.\nAlways handle errors in asynchronous code.\nBe aware of the event loop and how it affects the execution of your code.\nUse Promise.all for concurrent operations when appropriate.\nAvoid blocking the main thread with long-running synchronous operations.\n\nTip\nConcurrency Vs Parallelism\nClarify the difference between concurrency (managing multiple tasks over the same time period) and parallelism (executing multiple tasks simultaneously).\nJavaScript is single-threaded but can handle concurrent operations through asynchronous programming, even though it doesn’t perform tasks in parallel unless using Web Workers.\nBest Practices Enhancements\nAvoiding Overuse of Async/Await\n\n\nExplanation: Not all functions need to be asynchronous. Overusing async can lead to unnecessary promise creation, which can affect performance.\n\n\nExample:\n// Unnecessary async\nasync function add(a, b) {\n  return a + b;\n}\n \n// Better\nfunction add(a, b) {\n  return a + b;\n}\n\n\nHandling Multiple Asynchronous Operations in Loops\n\n\nInefficient Approach:\nfor (const url of urls) {\n  await fetchAndProcess(url);\n}\n\n\nEfficient Approach:\nawait Promise.all(urls.map(url =&gt; fetchAndProcess(url)));\n\n\nInsight: Running asynchronous operations in parallel when possible improves performance.\n\n\nUsing Linters and Code Style Guides\n\n\nExplanation: Enforce consistent asynchronous code patterns using tools like ESLint with plugins for promises and async/await.\n\n\nExample ESLint Configuration:\n{\n  &quot;plugins&quot;: [&quot;promise&quot;],\n  &quot;rules&quot;: {\n    &quot;promise/always-return&quot;: &quot;error&quot;,\n    &quot;promise/no-return-wrap&quot;: &quot;error&quot;,\n    &quot;promise/param-names&quot;: &quot;error&quot;\n  }\n}\n\n\nHandling Await in Loops and Conditional Statements\n\nPitfall: Using await inside loops or conditionals without proper understanding can lead to sequential execution and performance issues.\n\nUse Promise.all to run tasks in parallel when order doesn’t matter. If order matters, consider refactoring the code to allow for concurrency.\nCertainly! Here’s an expanded explanation of synchronous vs asynchronous exceptions, tailored for junior developers:\nSynchronous Vs. Asynchronous Exceptions\nSynchronous Exceptions\nSynchronous exceptions occur in the normal flow of program execution. They are immediately caught by surrounding try-catch blocks.\ntry {\n  console.log(&quot;Start of try block&quot;);\n  throw new Error(&#039;Synchronous error&#039;);\n  console.log(&quot;This line will never be executed&quot;);\n} catch (error) {\n  console.error(&quot;Caught synchronous error:&quot;, error.message);\n}\nconsole.log(&quot;Program continues executing&quot;);\n \n// Output:\n// Start of try block\n// Caught synchronous error: Synchronous error\n// Program continues executing\nKey points:\n\nThe error is thrown and caught immediately.\nCode execution in the try block stops at the point where the error is thrown.\nThe catch block is executed right away.\nProgram execution continues after the try-catch block.\n\nAsynchronous Exceptions\nAsynchronous exceptions occur in code that runs at a later time, such as in Promises, setTimeout, or event callbacks. These cannot be caught by a regular try-catch block surrounding the asynchronous function call.\ntry {\n  console.log(&quot;Start of try block&quot;);\n  Promise.reject(new Error(&#039;Asynchronous error&#039;));\n  console.log(&quot;This line will be executed&quot;);\n} catch (error) {\n  console.error(&quot;This catch block will not catch the async error&quot;);\n}\n \n// Proper way to handle asynchronous errors\nPromise.reject(new Error(&#039;Asynchronous error&#039;))\n  .catch(error =&gt; {\n    console.error(&quot;Caught asynchronous error:&quot;, error.message);\n  });\n \nconsole.log(&quot;Program execution continues immediately&quot;);\n \n// Output:\n// Start of try block\n// This line will be executed\n// Program execution continues immediately\n// Caught asynchronous error: Asynchronous error\nKey points:\n\nThe Promise.reject doesn’t throw an error immediately; it schedules it for later.\nThe try-catch block surrounding the Promise creation is ineffective for catching the async error.\nAsynchronous errors must be handled using .catch() on Promises or try-catch within async functions.\nThe program continues executing immediately, not waiting for the Promise to settle.\n\nWhy This Matters\n\n\nError Propagation: Synchronous errors propagate up the call stack immediately, while asynchronous errors do not.\n\n\nDebugging: Synchronous errors provide a clear stack trace to the error’s origin. Asynchronous errors can be more challenging to trace.\n\n\nProgram Flow: Unhandled synchronous exceptions can halt program execution immediately. Unhandled asynchronous exceptions might not stop the program immediately but can lead to unexpected behavior.\n\n\nError Handling Strategies: Different strategies are needed for handling synchronous and asynchronous errors effectively.\n\n"},"Solution-for-Nginx-SSL-Certificate-Passphrase-Issue":{"title":"Solution for Nginx SSL Certificate Passphrase Issue","links":[],"tags":["post/medium","SoftwareDevelopment","Networking","Security"],"content":"Solution for Nginx SSL Certificate Passphrase Issue\nEnsuring the seamless operation of your Nginx server, especially in automated environments like Docker, is crucial. This guide walks you through diagnosing and resolving the issue where Nginx fails to load an SSL certificate due to an encrypted key file requiring a passphrase.\nProblem Diagnosis\nLog Analysis\nReviewing the Nginx error logs reveals the following message:\nnginx: [emerg] cannot load certificate key &quot;/etc/ssl/certs/wildcard_eduroam_kr.key&quot;: PEM_read_bio_PrivateKey() failed\n(SSL: error:1400006B:UI routines::processing error:while reading strings error:0480006D:PEM routines::problems getting password\nerror:07880109:common libcrypto routines::interrupted or cancelled error:07880109:common libcrypto routines::interrupted or\ncancelled error:04800068:PEM routines::bad password read)\nThis error indicates that the wildcard_eduroam_kr.key file is encrypted and requires a passphrase, which Nginx cannot automatically provide during startup.\nRemoving the Passphrase From the Key File\nWhy Remove the Passphrase?\nFor automated environments such as Docker, manual passphrase entry during server startup is impractical. Removing the passphrase ensures Nginx can automatically load the SSL key, facilitating seamless automated deployments and operations.\nSteps to Remove the Passphrase\n\n\nExecute OpenSSL Command\nUse the openssl rsa command to create a new key file without the passphrase:\nopenssl rsa -in wildcard_eduroam_kr.key -out wildcard_eduroam_kr.key.no_pass\n\n\nEnter Passphrase\nWhen prompted, enter the current passphrase for the key file:\nEnter pass phrase for wildcard_eduroam_kr.key:\nThis will generate a new key file without a passphrase.\n\n\nVerify the New Key File\nEnsure the new key file has been created successfully:\nls -l wildcard_eduroam_kr.key.no_pass\nAnd, replace wildcard_eduroam_kr.key!\n\n\nModifying Docker Compose Configuration\nUpdating the docker-compose.yml File\nModify your docker-compose.yml to use the new key file without a passphrase:\nnginx:\n  logging:\n    driver: &quot;json-file&quot;\n    options:\n      max-size: &quot;50m&quot;\n  environment:\n    - TZ=Asia/Seoul\n  image: nginx:latest\n  container_name: nginx\n  volumes:\n    - ./nginx/nginx.conf:/etc/nginx/nginx.conf\n    - ./nginx/certs/cert_wildcard.eduroam.kr.crt:/etc/ssl/certs/cert_wildcard.eduroam.kr.crt\n    - ./nginx/certs/wildcard_eduroam_kr.key:/etc/ssl/certs/wildcard_eduroam_kr.key\n  deploy:\n    restart_policy:\n      condition: unless-stopped\n  ports:\n    - 443:443\n  networks:\n    - public\n    - private\nRebuilding and Restarting Docker Containers\nRebuild Docker Image and Restart Containers\nReflect the changes by rebuilding the Docker image and restarting the containers:\ndocker compose down\ndocker compose build\ndocker compose up -d\nRebuilding ensures that the new, unencrypted key file is used, as the key files are typically excluded from version control for security reasons and must be explicitly included in the build process.\nVerifying the Resolution\nCheck Nginx Container Logs\nConfirm that the issue is resolved by inspecting the Nginx container logs:\ndocker-compose logs nginx\nValidate Successful Startup\nEnsure the Docker container is running correctly:\ndocker ps\n\nFinally, verify that there are no errors related to certificate loading in the logs:\ndocker logs [nginx-container-ID]\n"},"Sound/게인-스트럭처(Gain-Structure)":{"title":"게인 스트럭처(Gain Structure)","links":["Sound/신호-대-잡음비(SNR)"],"tags":["AudioEngineering","LiveSound","SignalProcessing"],"content":"Gain Structure란 무엇인가?\nGain Structure는 오디오 신호의 각 단계에서 신호의 레벨을 최적화하여 왜곡 없이 깨끗한 사운드를 유지하는 데 필수적인 요소입니다. 각 장비와 시스템 내에서 신호의 레벨을 조정하여 신호 대 잡음비(SNR)를 최대화하고 왜곡 없이 신호의 청정도를 유지하는 것을 목표로 합니다. 올바른 Gain Structure 설정은 믹스의 균형과 다이내믹 레인지를 확보하며, 클리핑이나 신호 과부하를 방지합니다.\nGain의 정의\nGain은 오디오 시스템에서 신호의 강도를 조절하는 핵심 요소입니다. Gain 구조의 맥락에서 Gain은 다음과 같이 정의됩니다:\n\n\nGain의 기본 개념:\n\n입력 신호 대비 출력 신호의 증폭 비율을 나타냅니다.\n데시벨(dB) 단위로 측정되며, 양수 값은 증폭을, 음수 값은 감쇠를 의미합니다.\n\n\n\nGain의 주요 특성:\n\n신호의 진폭을 변경합니다.\n신호의 파워를 조절하지만, 반드시 음량의 변화를 의미하지는 않습니다.\n오디오 체인의 각 단계(프리앰프, 믹서, 프로세서 등)에서 조절될 수 있습니다.\n\n\n\nGain 조절의 목적:\n\n최적의 신호 대 잡음비(SNR)를 달성합니다.\n다음 단계의 장비에 적절한 레벨의 신호를 제공합니다.\n오디오 시스템 전체에서 일관된 신호 레벨을 유지합니다.\n\n\n\nGain vs 볼륨:\n\nGain은 주로 입력 단계에서 신호의 강도를 조절합니다.\n볼륨은 일반적으로 출력 단계에서 최종 음량을 조절합니다.\n\n\n\nGain을 올바르게 설정하는 것은 깨끗한 오디오 신호를 유지하고, 노이즈를 최소화하며, 시스템의 다이내믹 레인지를 최대화하는 데 중요합니다. 이는 전체 오디오 체인에서 최적의 성능을 얻기 위한 Gain 구조의 기초가 됩니다.\nGain Structure 설정 방법\n1. 입력 Gain 설정\n\n\n목적: 신호가 너무 작지도, 너무 크지도 않게 적절한 레벨로 설정해, 깨끗한 소리가 나게 합니다.\n\n\n설정 방법:\n\n\n아날로그 시스템:\n\n미터기의 0dB를 기준으로 신호를 맞춥니다. 신호가 노란색이나 녹색에 머무르면 적절한 상태입니다.\n자세한 내용은 위키피디아에서 확인할 수 있습니다.\n\n\n\n디지털 시스템:\n\n-12dBFS에서 -18dBFS 사이로 신호를 설정해, 충분한 헤드룸을 남겨 클리핑을 방지합니다.\nLED 미터가 녹색 또는 노란색일 때, 신호가 적절한 수준입니다. Sound on Sound를 참고하세요.\n\n\n\n\n\n주의 사항:\n\n빨간색 LED가 켜지면 클리핑 경고입니다. 이때는 Gain을 줄여 0dBFS를 넘지 않게 해야 합니다. Radio World와 Audio University에서 더 많은 정보를 얻을 수 있습니다.\n\n\n\n2. Unity Gain 적용\n\n목적: 믹서의 각 단계에서 신호 레벨이 일관되게 유지되도록 하는 것이 목표입니다.\n방법: EQ, 인서트, 그룹 버스, 입력 페이더, 마스터 출력에서 Unity Gain을 유지합니다. 0dB로 설정하여 신호가 그대로 전달되게 합니다.\n\n3. 출력 레벨 확인\n\n목적: 출력 신호가 과도하게 증폭되거나 너무 약하지 않은지 확인해, 전체 믹스의 균형을 유지합니다.\n방법: 전체 믹스를 재생하며 출력 레벨을 모니터링하고, 페이더를 최대한 올려도 충분한 볼륨이 나오지 않으면 Gain을 재조정합니다.\n\n4. Unity Gain 설정 단계\n\n목적: 모든 채널의 초기 레벨을 동일하게 설정하여 믹스를 준비합니다.\n\n각 채널을 뮤트 상태로 설정.\n페이더를 0dB로 올립니다.\n신호가 들어오는지 표시등을 확인합니다.\n솔로(Solo) 를 활성화하고 뮤트 해제.\n입력 Gain을 조정하여 피크가 발생하지 않도록 설정.\n모든 채널에서 이 과정을 반복.\n\n\n\nGain Structure의 중요성\n신호 대 잡음비(SNR) 향상\n신호 대 잡음비(SNR): 원하는 오디오 신호의 레벨과 배경 노이즈 레벨 사이의 비율을 나타냅니다. SNR이 높을수록 더 깨끗하고 선명한 사운드를 얻을 수 있습니다.\n향상 방법:\n\n각 단계에서 적절한 Gain을 설정하여 신호 레벨을 최적화합니다.\n입력 Gain을 충분히 높여 노이즈 플로어보다 훨씬 높은 레벨을 유지합니다.\n동시에 클리핑을 방지하기 위해 최대 허용 레벨 이하로 유지합니다.\n\n예를 들어, 마이크 프리앰프의 Gain을 조정할 때, 신호가 노이즈 플로어보다 충분히 높지만 클리핑되지 않는 레벨로 설정합니다. 이는 일반적으로 디지털 시스템에서 -18dBFS에서 -12dBFS 사이의 평균 레벨을 목표로 합니다\nADDITIONAL STEP\n디지털 오디오 시스템에서 -12dBFS에서 -18dBFS로 신호를 설정하는 것은 일반적인 관행입니다. 이는 신호의 왜곡을 방지하고, 충분한 헤드룸을 확보하기 위한 설정입니다. 특히 유럽 방송 연합(EBU) 에서는 R68 표준에 따라 -18dBFS를 기준으로 설정하며, 미국 영화 텔레비전 엔지니어 협회(SMPTE) 에서는 RP155 표준을 따르며 -20dBFS를 권장합니다​(Sound on Sound)​(Radio World).\n이러한 값들은 대부분의 24비트 시스템에서 신호 처리 중 발생할 수 있는 피크를 안정적으로 처리할 수 있도록 충분한 여유 공간을 제공하며, 디지털 클리핑을 방지하는 데 중요한 역할을 합니다. 따라서, -12dBFS에서 -18dBFS는 대부분의 스튜디오 녹음 및 방송 환경에서 신뢰할 수 있는 설정 값입니다​(PEDAL POINT SOUND).\nUnity Gain 유지\nUnity Gain: 신호가 장비를 통과할 때 레벨 변화 없이 입력과 출력이 동일한 상태를 의미합니다. 이는 절대적인 0dB를 의미하는 것이 아니라, 입력 신호와 출력 신호의 레벨이 동일함을 나타냅니다. 각 장비로 들어오는 레벨이 나가는 레벨과 동일해야 하며, 신호 경로의 다음 장치도 동일한 레벨을 받아야 합니다.\n\n\n정의: 입력 신호의 레벨과 출력 신호의 레벨이 동일한 상태\n\n\n목적: 신호 경로 전체에서 일관된 레벨을 유지하여 최적의 신호 품질 확보\n\n\n예시:\n\n사운드보드의 출력 미터가 0dB를 표시하면, 다음 장치인 시스템 크로스오버의 입력도 0dB여야 합니다.\n크로스오버를 떠나는 신호도 초기에는 0dB이어야 합니다.\n\n\n\n주의사항:\n\n일부 장치는 특별히 Gain을 증가시키거나 감소시키는 용도로 사용됩니다.\nUnity Gain을 먼저 적용한 후 필요에 따라 출력 레벨을 조정해야 합니다.\n\n\n\n유지 방법:\n\n각 장비의 입력과 출력 레벨을 동일하게 설정합니다.\n아날로그 시스템에서는 보통 0dB, 디지털 시스템에서는 -18dBFS를 기준으로 합니다.\n믹서의 페이더를 0dB 위치에 두고 시작합니다.\n\n이는 페이더가 신호를 증폭하거나 감쇠시키지 않는 지점입니다.\n\n\n예를 들어, 믹서에서 채널 출력이 0dB일 때 이퀄라이저 입력도 0dB, 출력도 0dB로 설정하여 전체 신호 경로에서 일관된 레벨을 유지합니다.\n\n\n\n주의사항\n\nUnity Gain은 ‘무음’을 의미하지 않습니다. 신호는 여전히 존재하며, 단지 레벨이 변하지 않을 뿐입니다.\n일부 장비(예: 컴프레서, 리미터)는 의도적으로 게인을 변경하기 위해 사용됩니다. 이런 경우 Unity Gain 설정 후 필요에 따라 출력 레벨을 조정합니다.\n전체 시스템에서 Unity Gain을 유지하면서도, 개별 요소의 레벨은 믹싱 목적에 따라 조정될 수 있습니다.\n\n피드백 및 왜곡 방지\n피드백: 출력 신호가 다시 입력으로 들어가 발생하는 원치 않는 소리 순환입니다.\n왜곡: 신호가 과도하게 증폭되어 원래의 파형이 변형되는 현상입니다.\n방지 방법:\n\n각 단계에서 적절한 Gain 설정으로 과도한 증폭을 피합니다.\n디지털 시스템에서는 절대 0dBFS를 넘지 않도록 합니다.\n아날로그 시스템에서도 최대 출력 레벨을 넘지 않도록 주의합니다.\n\n라이브 사운드에서는 마이크와 스피커 사이의 거리, 피커의 위치, Gain 설정을 조절하여 피드백을 방지하고, 레코딩에서는 각 단계의 레벨을 모니터링하여 왜곡을 방지합니다.\n음질 제어\n전체 시스템의 SNR을 완전히 제어하여 왜곡과 전반적인 음질에 직접적인 영향을 미칩니다.\n제어 방법:\n\n각 단계에서 최적의 동작 레벨을 유지합니다.\n특정 장비나 플러그인의 특성을 활용하기 위해 의도적으로 Gain을 조절할 수 있습니다.\n전체 믹스의 밸런스를 위해 개별 채널의 Gain을 조절합니다.\n\n예를 들어, 튜브 프리앰프를 사용할 때 약간의 오버드라이브를 위해 입력 Gain을 높이거나, 컴프레서의 특성을 활용하기 위해 입력 Gain을 조절할 수 있습니다.\n헤드룸(Headroom) 확보\n헤드룸은 최대 신호 레벨과 현재 신호 레벨 사이의 여유 공간을 의미합니다. 충분한 헤드룸을 확보함으로써 예상치 못한 신호 피크로 인한 클리핑을 방지할 수 있습니다.\n헤드룸 확보 방법:\n\n각 단계에서 신호가 최대 레벨에 도달하지 않도록 여유를 둡니다.\n특히 라이브 사운드에서는 갑작스러운 볼륨 증폭에도 대응할 수 있도록 헤드룸을 넉넉하게 설정합니다.\n디지털 시스템에서는 최대 -6dBFS 이상의 헤드룸을 유지하는 것이 일반적입니다.\n\n노이즈 플로어(Noise Floor) 관리\n노이즈 플로어는 시스템 내에 항상 존재하는 배경 잡음의 레벨을 의미합니다. 노이즈 플로어를 낮게 유지함으로써 신호 대 잡음비(SNR)를 향상시킬 수 있습니다.\n관리 방법:\n\n고품질의 케이블과 장비를 사용하여 잡음 유입을 최소화합니다.\n각 단계의 Gain을 적절히 설정하여 노이즈 플로어보다 충분히 높은 신호 레벨을 유지합니다.\n불필요한 신호 경로를 제거하고, 신호 체인을 단순화하여 노이즈 축적을 방지합니다.\n\n추가 개념\n헤드룸(Headroom)과 그 중요성\n헤드룸은 신호가 최대 레벨에 도달하기 전에 남겨둔 여유 공간을 의미합니다. 충분한 헤드룸을 확보함으로써 예상치 못한 신호 피크로 인한 클리핑을 방지할 수 있습니다. 헤드룸은 특히 라이브 사운드와 레코딩 환경에서 중요한데, 갑작스러운 소리 변화나 역동적인 연주에 대응할 수 있게 해줍니다.\n헤드룸 확보 방법:\n\n각 장비의 Gain 설정 시 최대 레벨보다 6dB에서 12dB 정도 낮게 설정합니다.\n믹스 전체에서 신호가 너무 가까이 접근하지 않도록 모니터링합니다.\n디지털 시스템에서는 최대 -6dBFS 이상의 헤드룸을 유지하는 것이 일반적입니다.\n\n신호 체인 내 Gain Staging의 역할\nGain Staging은 신호 체인의 각 단계에서 최적의 Gain 레벨을 유지하여 전체 시스템의 음질을 극대화하는 과정을 의미합니다. 올바른 Gain Staging은 신호가 모든 장비를 통과하면서 최적의 레벨을 유지하도록 도와줍니다.\n신호 체인 설계 시 고려사항:\n\n각 장비의 입력과 출력 임피던스를 일치시켜 신호 손실을 방지합니다.\n아날로그와 디지털 경로 간의 레벨 매칭을 신경 씁니다.\n각 단계에서의 Gain 조정을 통해 신호의 품질을 유지하고, 노이즈 축적을 최소화합니다.\n\n메터링 도구의 활용\n메터링 도구는 Gain Structure를 관리하는 데 필수적인 도구입니다. VU 미터, 피크 미터, RMS 미터 등을 활용하여 신호 레벨을 정확히 모니터링할 수 있습니다.\n메터링 도구 사용법:\n\nVU 미터: 평균 레벨을 보여주어 믹스의 전체적인 밸런스를 확인하는 데 유용합니다.\n피크 미터: 신호의 최고 피크 레벨을 실시간으로 모니터링하여 클리핑을 방지합니다.\nRMS 미터: 신호의 에너지를 측정하여 다이내믹 레인지를 평가합니다.\n\n예제\n\n\n대형 콘서트의 실전 사례:\n\n대규모 콘서트에서는 다중 신호 경로를 관리해야 하므로, Gain Structure를 잘못 설정하면 특정 트랙이나 악기 소리가 묻히거나 왜곡될 수 있습니다.\n이를 해결하기 위해 현장에서 매번 미세 조정을 거치며 실시간으로 사운드의 변화를 모니터링합니다.\n헤드룸을 충분히 확보하여 갑작스러운 볼륨 변화에도 대비합니다.\n\n\n\n레코딩 스튜디오에서의 Gain Structure:\n\n스튜디오에서는 아날로그와 디지털 장비를 혼용하여 사용하는 경우가 많습니다.\n이 경우 각 장비 간의 신호 전달에서 발생할 수 있는 레벨 차이를 일관성 있게 유지하는 것이 중요합니다.\n믹싱 엔지니어는 이러한 변수를 고려하여 Gain Structure를 설정합니다.\n메터링 도구를 활용하여 각 단계의 레벨을 정확히 모니터링하고, 노이즈 플로어를 최소화합니다.\n\n\n\n참고 자료\n\nGain Structure 101 - Seismic Audio\nCore Principles of Live Sound and Mixing - Mixing Music Live\nLive Sound Gain Structure Best Practices - ProSoundWeb\nMixing Consoles &amp; Gain Structure - Sound on Sound Magazine\n"},"Sound/그라운드-루프(Ground-Loop)":{"title":"그라운드 루프(Ground Loop)","links":["험-(Hum)","tags/AudioNoise","갈바닉-절연-(Galvanic-Isolation)","tags/ElectricalEngineering","디퍼렌셜-시그널링-(Differential-Signaling)","tags/SignalProcessing","접지-(Grounding)","tags/ElectricalSafety"],"tags":["AudioEngineering","ElectricalEngineering","SoundQuality","NoiseReduction","SignalProcessing","terminology","GroundLoop","AudioNoise","ElectricalSafety"],"content":"그라운드 루프 (Ground Loop)\nWhat is Ground Loop\n\n\n정의 (Definition):\n\n그라운드 루프는 오디오 시스템에서 발생하는 전기적 간섭 현상으로, 두 개 이상의 장치가 서로 다른 접지점을 통해 연결될 때 발생합니다(Ballou, 2015).\n이는 시스템 내에서 원치 않는 전류가 흐르게 되어 오디오 신호에 노이즈나 험(hum)을 유발합니다(White &amp; Louie, 2005).\n그라운드 루프는 일반적으로 60Hz(미국) 또는 50Hz(유럽, 아시아 등) 주파수의 험으로 나타납니다(Huber &amp; Runstein, 2013).\n\n\n\n예시 (Examples):\n\n믹싱 콘솔과 파워 앰프가 서로 다른 전원 콘센트에 연결되어 있을 때 그라운드 루프가 발생할 수 있습니다.\n컴퓨터의 오디오 인터페이스와 외부 프리앰프 사이에 그라운드 루프가 형성되어 녹음 시 험이 들리는 경우.\n비디오 프로젝터와 오디오 시스템이 연결된 홈 시어터 설치에서 화면에 노이즈 라인이 보이고 스피커에서 험이 들리는 현상.\n\n\n\n그라운드 루프의 발생 원인\n\n다중 접지 지점: 여러 장치가 서로 다른 접지 지점을 사용하여 연결될 때, 접지 간 전위 차이로 인해 그라운드 루프가 형성될 수 있습니다.\n비균형 전원 공급: 전력 공급 장치가 완전히 접지되지 않았거나, 접지 임피던스가 높을 경우 전위 차이가 발생할 수 있습니다.\n케이블 배치: 오디오 케이블이 전원 케이블과 가까이 배치되거나, 장비 간 케이블 길이가 상이할 경우 간섭이 증가할 수 있습니다.\n전자기 간섭 (EMI): 외부 전자기장이 시스템 내의 접지 루프에 영향을 미쳐 노이즈를 유발할 수 있습니다.\n\n그라운드 루프의 영향\n\n오디오 품질 저하: 험 소리, 윙윙거리는 소리, 또는 기타 잡음이 오디오 신호에 섞여 음질을 저하시킵니다.\n장비 손상: 지속적인 불필요한 전류 흐름은 오디오 장비의 성능 저하 또는 손상을 초래할 수 있습니다.\n신호 왜곡: 신호 경로에 간섭이 발생하여 원래의 오디오 신호가 왜곡될 수 있습니다.\n\n그라운드 루프의 진단 방법\n\n험 소리 확인: 오디오 시스템에서 지속적인 험 소리가 발생하는지 확인합니다.\n장비 분리 테스트: 모든 장비를 하나씩 분리하여 험 소리가 사라지는 장비를 찾습니다.\n접지 점 점검: 시스템 내의 모든 접지 지점을 점검하고, 접지 연결이 올바르게 이루어져 있는지 확인합니다.\n케이블 검토: 오디오 케이블이 전원 케이블과 물리적으로 간섭되지 않도록 재배치합니다.\n\n그라운드 루프 해결 방안\n\n갈바닉 절연 (Galvanic Isolation):\n\n갈바닉 절연 장치를 사용하여 두 회로 간의 전기적 연결을 차단함으로써 그라운드 루프를 방지합니다. 이는 트랜스포머 기반 아이솔레이터나 광학 아이솔레이터를 통해 구현할 수 있습니다.\n\n\n균형 잡힌 오디오 연결 (Balanced Audio Connections):\n\nXLR 케이블과 같은 균형 잡힌 케이블을 사용하여 노이즈를 상쇄시키고, 신호의 무결성을 유지합니다\n\n\n단일 접지 점 사용 (Single Ground Point):\n\n시스템 내의 모든 장비를 단일 접지 지점으로 연결하여 전위 차이를 최소화합니다.\n\n\n접지 루프 브레이커 (Ground Loop Breakers):\n\n접지 루프 브레이커를 설치하여 불필요한 전류 흐름을 차단하고, 험 소리를 제거합니다.\n\n\n전원 필터링 및 차단:\n\n전원 공급 장치에 필터를 추가하거나, 노이즈를 차단하는 차단기를 사용하여 간섭을 줄입니다.\n\n\n\nLiterature Review\nBallou, 2015\n\nHandbook for Sound Engineers\n\nSource: Routledge\n\n\n주요 내용 (Key points):\n\n그라운드 루프의 원인과 메커니즘에 대한 상세한 설명을 제공합니다.\n다양한 오디오 시스템에서 그라운드 루프를 식별하고 해결하는 방법을 논의합니다.\n그라운드 루프 방지를 위한 시스템 설계 및 설치 가이드라인을 제시합니다.\n\n\n\nHuber &amp; Runstein, 2013\n\nModern Recording Techniques\n\nSource: Focal Press\n\n\n주요 내용 (Key points):\n\n레코딩 스튜디오 환경에서 발생하는 그라운드 루프 문제를 다룹니다.\n그라운드 루프로 인한 노이즈를 제거하기 위한 실용적인 기술과 도구를 소개합니다.\n균형 잡힌(balanced) 오디오 연결의 중요성과 그라운드 루프 방지에 미치는 영향을 설명합니다.\n\n\n\n관련 개념 (Related Concepts)\n\n험 (Hum)AudioNoise\n\n그라운드 루프로 인해 발생하는 가장 일반적인 형태의 오디오 노이즈로, 주로 전원 주파수(50/60Hz)와 관련이 있습니다.\n\n\n갈바닉 절연 (Galvanic Isolation)ElectricalEngineering\n\n두 회로 사이의 전기적 연결을 차단하여 그라운드 루프를 방지하는 기술입니다.\n\n\n디퍼렌셜 시그널링 (Differential Signaling)SignalProcessing\n\n균형 잡힌(balanced) 오디오 연결에서 사용되는 기술로, 그라운드 루프로 인한 노이즈를 상쇄시키는 데 도움이 됩니다.\n\n\n접지 (Grounding)ElectricalSafety\n\n올바른 접지 기술은 그라운드 루프 형성을 방지하고 전기 안전을 보장하는 데 중요합니다.\n\n\n"},"Sound/신호-대-잡음비(SNR)":{"title":"신호 대 잡음비(SNR)","links":["다이나믹-레인지-(Dynamic-Range)","tags/DynamicRange","노이즈-플로어-(Noise-Floor)","tags/NoiseFloor","비트-뎁스-(Bit-Depth)","tags/BitDepth","프리앰프-게인-(Preamp-Gain)","tags/PreampGain"],"tags":["AudioEngineering","SignalProcessing","SoundQuality","NoiseReduction","AudioMeasurement","terminology","SNR","DynamicRange","NoiseFloor","BitDepth","PreampGain"],"content":"신호 대 잡음비 (Signal-to-Noise Ratio)\nWhat is Signal-to-Noise Ratio (SNR)\n\n\n정의 (Definition):\n\nSNR은 원하는 신호의 레벨과 배경 잡음 레벨 사이의 비율을 나타내는 측정값입니다. 일반적으로 데시벨(dB) 단위로 표현됩니다(Sound On Sound, n.d.).\n신호 대 잡음비는 오디오 시스템의 품질과 성능을 평가하는 중요한 지표로, 높을수록 더 깨끗하고 명확한 소리를 의미합니다(RØDE, n.d.).\nSNR은 (신호 전력 / 잡음 전력)의 비율로 계산되며, 로그 스케일로 표현됩니다(Cadence PCB Solutions, 2020).\n\n\n\n예시 (Examples):\n\n고품질 오디오 인터페이스는 일반적으로 100dB 이상의 SNR을 가집니다.\n전문가용 마이크로폰의 경우, 70-80dB 이상의 SNR이 일반적입니다.\n디지털 오디오 시스템에서 16비트 오디오의 이론적 최대 SNR은 약 96dB입니다.\n\n\n\nLiterature Review\nRØDE, n.d.\n\nWhat Is Signal-to-noise Ratio?\n\nSource: RØDE Official Website\n\n\n주요 내용 (Key points):\n\nSNR의 기본 개념과 중요성을 설명합니다.\n내부(전자) 노이즈와 외부(환경) 노이즈의 차이를 설명합니다.\n마이크 배치가 SNR에 미치는 영향을 시각적으로 보여줍니다.\n\n\n\nCadence PCB Solutions, 2020\n\nWhat is Signal to Noise Ratio and How to calculate it?\n\nSource: Cadence PCB Solutions Blog\n\n\n주요 내용 (Key points):\n\nSNR 계산 방법을 자세히 설명합니다.\nSNR과 채널 용량의 관계를 Shannon의 법칙을 통해 설명합니다.\n무선 네트워크에서의 SNR 중요성을 강조합니다.\n\n\n\n관련 개념 (Related Concepts)\n\n\n다이나믹 레인지 (Dynamic Range)DynamicRange\n\n다이나믹 레인지는 시스템이 처리할 수 있는 최소 신호 레벨과 최대 신호 레벨의 차이를 나타냅니다. SNR과 밀접한 관련이 있지만, 다이나믹 레인지는 주로 왜곡 없이 처리할 수 있는 신호의 범위를 의미합니다.\n\n\n\n노이즈 플로어 (Noise Floor)NoiseFloor\n\n노이즈 플로어는 시스템에 존재하는 배경 잡음의 레벨을 나타냅니다. SNR을 개선하기 위해서는 노이즈 플로어를 낮추는 것이 중요합니다.\n\n\n\n비트 뎁스 (Bit Depth)BitDepth\n\n디지털 오디오에서 비트 뎁스는 SNR과 직접적인 관련이 있습니다. 비트 뎁스가 높을수록 이론적으로 더 높은 SNR을 얻을 수 있습니다.\n\n\n\n프리앰프 게인 (Preamp Gain)PreampGain\n\n프리앰프의 게인 설정은 입력 신호의 레벨을 높이는 동\n\n\n"},"Sound/신호-흐름-(Signal-Flow)":{"title":"신호 흐름 (Signal Flow)","links":["Sound/그라운드-루프(Ground-Loop)","Sound/게인-스트럭처(Gain-Structure)","Sound/하이패스-필터(High-Pass-Filter)","VCA-그룹","DCA-그룹","임피던스-매칭","PFL(Pre-Fader-Listen)","Sound/하울링(Feedback)"],"tags":["음향"],"content":"왜 시그널 플로우를 알아야 할까?\n\n시그널 플로우(Signal Flow)는 음향 시스템에서 오디오 신호가 어떻게 이동하고 처리되는지를 나타내는 핵심 개념입니다. 시니어 사운드 엔지니어로서 시그널 플로우를 정확히 이해하지 못하면 시스템 설정, 문제 해결, 믹싱 등에서 심각한 어려움을 겪을 수 있습니다. 시그널 플로우는 음향 시스템의 ‘지도’와 같으며, 이를 통해 신호의 흐름을 추적하고 최적화할 수 있습니다.\n신호 흐름 (Signal Flow)\n시그널 플로우는 입력 소스부터 최종 출력까지 오디오 신호가 거치는 모든 단계를 포함합니다. 각 단계에서 신호는 처리되고 변형되며, 이는 최종 사운드 품질에 직접적인 영향을 미칩니다.\n기본 시그널 플로우 단계\n\n입력 소스: 마이크, 악기, 라인 입력 등\n프리앰프(Preamp): 입력 신호의 증폭 및 레벨 조정\n인서트 포인트(Insert Point): 외부 프로세서 연결 지점\n이퀄라이저(EQ): 주파수 대역별 톤 조절\n다이내믹 프로세서: 컴프레서, 게이트 등\n이펙트 센드/리턴(Effect Send/Return): 이펙트 프로세서로의 신호 경로\n믹싱 버스(Mixing Bus): 여러 신호의 합성\n메인 출력(Main Output): 최종 믹스된 신호\n매트릭스 출력(Matrix Output): 별도 출력 구성\n파워 앰프(Power Amp): 스피커 구동을 위한 증폭\n스피커(Speaker): 전기 신호를 음향 에너지로 변환\n\n예시 (병원의 환자)\n음향 시스템에서 시그널 플로우(Signal Flow) 는 매우 중요한 개념입니다. 간단히 말해, 소리가 입력 장치(마이크, 악기 등)에서 시작하여 최종 출력(스피커)으로 나가는 과정에서 어떤 경로를 따라가고, 어떻게 처리되는지를 설명하는 것입니다. 이 개념을 병원에서 환자를 치료하는 과정에 비유하면 훨씬 쉽게 이해할 수 있습니다.\n환자가 병원에 들어오는 것은 마치 마이크나 악기에서 소리가 처음 발생하는 순간과 같습니다. 이때 환자의 상태를 확인하는 단계는 프리앰프를 통해 소리 신호의 세기를 조정하는 과정과 같죠. 프리앰프는 소리가 너무 약하지 않도록 증폭해주는 장치입니다. 마치 간호사가 환자의 바이탈 사인을 체크하고 초기 상태를 파악하는 것처럼, 소리의 신호도 첫 단계에서 적절히 관리되어야 합니다.\n이후 필요에 따라 전문의의 진료나 추가 검사를 연결하는 과정은, 소리 신호 경로에 인서트 포인트를 사용해 외부 프로세서를 삽입하는 것과 비슷합니다. 여기서 환자는 상태에 따라 맞춤형 치료를 받게 되는데, 이 단계가 바로 음향 시스템에서 이퀄라이저를 통해 주파수를 조정하여 원하는 소리를 만드는 것과 같은 역할을 합니다. 이퀄라이저는 환자에게 맞춤형 치료를 제공하듯이 소리의 특정 주파수를 강화하거나 억제하여 최적의 사운드를 만들죠.\n치료가 진행되면, 때때로 약물 용량이나 치료 방법을 조절해야 하듯이, 음향 시스템에서도 다이내믹 프로세서를 사용하여 소리의 강약을 조절합니다. 컴프레서는 소리의 볼륨이 너무 커지지 않도록 조절하고, 게이트는 불필요한 배경 소음을 차단해줍니다.\n회복 단계에 들어선 환자는 재활 치료나 추가 치료를 받게 되는데, 이는 음향 시스템에서 리버브나 딜레이와 같은 이펙트 프로세서를 통해 소리에 공간감이나 깊이를 더하는 과정과 같습니다. 이 단계를 통해 소리가 더욱 풍부하게 들리죠.\n환자가 모든 치료를 마치고 퇴원할 때, 의료진은 종합적으로 환자의 상태를 평가합니다. 음향 시스템에서도 믹싱 버스를 통해 다양한 신호가 하나로 합쳐져 최종적으로 스피커로 출력됩니다. 이때 여러 신호를 잘 조화롭게 관리하는 것이 매우 중요하죠. 마지막으로, 환자가 퇴원 후에도 지역사회에서 건강하게 생활할 수 있도록 지원하듯이, 소리도 파워 앰프를 통해 증폭되어 스피커로 전달됩니다. 이렇게 소리는 사람들에게 들리고, 완성된 음향이 전달됩니다.\n이처럼, 시그널 플로우는 소리가 시작부터 끝까지 어떻게 이동하고 처리되는지를 설명하는 중요한 개념입니다. 환자가 병원에서 진단을 받고 치료를 거쳐 퇴원하는 과정처럼, 소리도 각 단계를 거쳐 최종적으로 완성된 형태로 청중에게 전달됩니다.\n신호 연결 방법과 체크 포인트\n1. 입력 소스 연결\n마이크 연결 시에는 XLR 케이블을 사용하여 발란스드(Balanced) 연결을 합니다. 이는 노이즈 저항성이 높아 장거리 전송에 적합합니다. 악기 연결의 경우 TS 또는 TRS 케이블을 사용하며, DI 박스를 통해 임피던스 매칭과 발란스드 신호로 변환합니다.\n\n케이블의 손상 여부와 연결 상태를 확인합니다. 손상된 케이블은 신호 손실이나 노이즈를 유발할 수 있습니다.\n콘덴서 마이크 사용 시 팬텀 파워(48V)가 필요한지 확인하고, 믹서에서 팬텀 파워를 활성화합니다.\nDI 박스의 그라운드 리프트 스위치 설정을 점검합니다. 그라운드 루프(Ground Loop) 로 인한 노이즈를 방지하기 위해 필요합니다.\n\n그라운드 루프(Ground Loop): 접지 경로가 두 개 이상 형성되어 전류가 순환하면서 발생하는 노이즈 문제입니다.\n\n\n\n2. 프리앰프 설정\n입력 게인을 조절하여 최적의 신호 레벨을 확보합니다. 적절한 게인 설정은 신호 대 잡음비(SNR)를 높여주며, 클리핑이나 왜곡을 방지합니다.\n\n피크 미터(Peak Meter) 를 확인하여 신호가 클리핑되지 않도록 합니다.\n게인이 너무 낮으면 노이즈가 증가하고, 너무 높으면 왜곡이 발생하므로 적절한 수준으로 조절합니다.\n게인 스트럭처(Gain Structure) 를 고려하여 시스템 전체의 레벨을 최적화합니다.\n\n게인 스트럭처(Gain Structure): 신호 경로의 각 단계에서 게인을 적절히 설정하여 신호 대 잡음비를 최적화하는 과정입니다.\n\n\n\n3. 인서트 포인트 활용\n인서트 포인트(Insert Point) 를 사용하여 외부 프로세서를 신호 경로에 삽입합니다.\n\n인서트 케이블의 연결 상태를 확인합니다.\n외부 장비의 입력 및 출력 레벨을 믹서와 매칭합니다.\n인서트 활성화 여부를 확인합니다.\n\n4. 이퀄라이저 설정\n각 채널의 주파수 응답을 조절하여 원하는 톤을 만듭니다. 불필요한 주파수 대역을 제거하여 깨끗한 사운드를 얻습니다.\n\n하울링이 발생하는 주파수를 식별하고 해당 주파수를 컷(Cut)합니다.\n보컬의 명료도를 높이기 위해 중고역대를 보강합니다.\n하이패스 필터(High-Pass Filter) 를 사용하여 저주파 노이즈를 제거합니다.\n\n하이패스 필터(High-Pass Filter): 설정된 주파수 이하의 저주파를 감쇄시키는 필터입니다.\n\n\n\n5. 다이내믹 프로세서 적용\n컴프레서를 사용하여 다이내믹 레인지를 조절하고, 게이트를 통해 불필요한 배경 노이즈를 제거합니다.\n\n적절한 스레시홀드(Threshold) 와 레시오(Ratio) 를 설정하여 원하는 압축 효과를 얻습니다.\n어택(Attack) 과 릴리즈(Release) 시간을 조절하여 자연스러운 사운드를 유지합니다.\n다이내믹 프로세서의 순서를 고려하여 신호 흐름을 최적화합니다.\n\n6. 이펙트 프로세서 사용\n리버브나 딜레이를 적용하여 공간감과 깊이감을 추가합니다.\n\n\n이펙트의 믹스 레벨과 프리딜레이(Pre-Delay) 를 설정하여 원본 신호와의 조화를 이룹니다.\n\n\n이펙트 센드가 프리-페이더(Pre-Fader) 인지 포스트-페이더(Post-Fader) 인지 확인하여 원하는 믹스 컨트롤을 확보합니다.\n\n프리-페이더(Pre-Fader): 페이더 위치와 상관없이 일정한 신호를 보내는 방식입니다.\n포스트-페이더(Post-Fader): 페이더 위치에 따라 보낸 신호의 레벨이 변하는 방식입니다.\n\n\n\n과도한 이펙트 사용을 피하여 명료도를 유지합니다.\n\n\n7. 믹싱 버스와 그룹 설정\n관련 채널을 그룹화하여 효율적인 제어를 가능하게 합니다. 버스를 통해 모니터 믹스나 이펙트 센드를 생성합니다.\n체크 포인트:\n\n각 채널의 버스 할당 상태를 확인하여 신호 흐름이 의도한 대로 이루어지는지 확인합니다.\n그룹 페이더 레벨과 뮤트 상태를 점검하여 불필요한 음량 변화나 무음 상태를 방지합니다.\nVCA 그룹 이나 DCA 그룹 을 활용하여 여러 채널의 레벨을 동시에 제어합니다.\n\nVCA 그룹: 전압 제어 증폭기를 사용하여 그룹 내 채널의 레벨을 조절하는 방식입니다.\nDCA 그룹: 디지털 컨트롤 앰플리피케이션으로, VCA와 유사하지만 디지털 믹서에서 사용됩니다.\n\n\n\n8. 출력 단계와 매트릭스 설정\n메인 출력 레벨을 조절하여 전체 음량을 관리하고, 매트릭스를 통해 녹음이나 방송 등 별도의 출력을 구성합니다.\n\n출력 레벨을 모니터링하여 클리핑을 방지합니다.\n출력 신호의 위상과 극성을 확인하여 음질 저하를 예방합니다.\n매트릭스 믹스를 설정하여 여러 출력으로 다양한 믹스를 제공합니다.\n\n9. 파워 앰프와 스피커 연결\n파워 앰프의 입력과 스피커의 연결 상태를 확인하고, 스피커의 임피던스와 앰프 출력이 매칭되는지 점검합니다.\n체크 포인트:\n\n스피커 케이블의 극성(+, -)을 정확하게 연결하여 위상 문제를 방지합니다.\n파워 앰프의 게인 설정을 적절하게 조절하여 스피커의 손상을 방지합니다.\n임피던스 매칭 을 통해 시스템의 효율성과 안정성을 확보합니다.\n\n임피던스 매칭: 앰프와 스피커의 임피던스를 맞춰 전력 전달을 최적화하는 과정입니다.\n\n\n\n신호 테스트 방법\n1. 라인 체크(Line Check)\n각 입력 채널별로 신호가 정상적으로 들어오는지 확인합니다. 마이크는 “테스트 1, 2, 3” 등의 음성으로, 악기는 실제 연주로 테스트합니다.\n\n채널 미터에서 신호 레벨을 확인하여 적절한 입력이 이루어지는지 점검합니다.\n소리가 나지 않을 경우 케이블, 마이크, DI 박스의 순서로 문제를 확인합니다.\nPFL(Pre-Fader Listen) 기능을 사용하여 각 채널의 신호를 개별적으로 모니터링합니다.\n\nPFL(Pre-Fader Listen): 페이더 위치와 상관없이 채널의 입력 신호를 모니터링할 수 있는 기능입니다.\n\n\n\n2. 화이트 노이즈/핑크 노이즈 테스트\n시스템의 주파수 응답을 확인하기 위해 화이트 노이즈나 핑크 노이즈를 재생하고, 스펙트럼 분석기를 사용하여 주파수 밸런스를 확인합니다.\n\n특정 주파수에서 피크나 딥(Dip)이 발견되면 이퀄라이저로 보정합니다.\n룸 어쿠스틱의 문제를 파악하여 필요 시 어쿠스틱 트리트먼트를 고려합니다.\n스피커의 위치와 각도를 조정하여 커버리지를 최적화합니다.\n\n3. 위상 테스트\n위상 반전된 신호를 사용하여 스피커의 위상 일치를 확인합니다. 모노 신호를 재생하여 위상 문제를 감지합니다.\n\n저주파에서의 위상 상쇄 현상을 확인하여 베이스 응답이 정상적인지 점검합니다.\n스피커의 극성 연결 오류를 수정하여 위상 문제를 해결합니다.\n멀티 마이크 설정 시 마이크 간의 위상 관계를 고려합니다.\n\n4. 타임 얼라인먼트(Time Alignment)\n여러 스피커 간의 시간 차이를 조정하여 일관된 사운드를 구현합니다. 딜레이 프로세서를 사용하여 필요한 시간 지연을 설정합니다.\n\n서브우퍼와 메인 스피커의 시간 차이를 조정하여 주파수 응답을 최적화합니다.\n딜레이 스피커 사용 시 메인 스피커와의 시간 차이를 정확히 설정합니다.\n모든 청취 위치에서 소리가 동시에 도달하도록 설정하여 음상의 정확성을 확보합니다.\n\n문제 해결을 위한 시그널 플로우 활용\n신호 경로 추적\n문제가 발생한 부분부터 신호의 흐름을 따라가며 원인을 파악합니다. 각 단계에서 신호의 존재 여부를 확인합니다.\n\n입력 소스 → 채널 게인 → 페이더 → 버스 → 출력 단계의 순서로 신호를 추적합니다.\n뮤트(Mute)나 솔로(Solo) 상태를 확인하여 신호 차단 여부를 점검합니다.\n디지털 믹서의 경우 신호 패치(Patch) 설정을 확인합니다.\n\n노이즈 및 하울링 문제 해결\n노이즈 발생 시 접지 문제나 케이블 손상 여부를 확인하고, 하울링 발생 시 마이크 위치 조정과 이퀄라이저로 문제 주파수를 컷(Cut)합니다.\n\n그라운드 루프(Ground Loop) 를 방지하기 위해 접지 상태를 점검하고, 필요 시 그라운드 리프트를 사용합니다.\n마이크와 스피커의 상대적 위치를 최적화하여 하울링을 최소화합니다.\n하울링(Feedback) 주파수를 정확히 식별하여 이퀄라이저로 감쇄합니다.\n\n하울링(Feedback): 마이크로 입력된 신호가 스피커를 통해 증폭되어 다시 마이크로 들어가는 순환 과정에서 특정 주파수가 과도하게 증폭되는 현상입니다.\n\n\n\nTMI\n디지털 믹서와 아날로그 믹서의 시그널 플로우 차이\n\n디지털 믹서는 유연한 신호 패칭과 다양한 내장 프로세서를 제공합니다.\n아날로그 믹서는 신호 경로가 물리적으로 고정되어 있어 직관적이지만 유연성이 떨어집니다.\n디지털 믹서 사용 시에는 신호 패칭과 라우팅 설정을 꼼꼼히 확인해야 합니다.\n\n게인 구조의 중요성\n\n시스템 전체에서 일관된 게인 스트럭처(Gain Structure) 를 유지하여 신호 대 잡음비를 최적화합니다.\n각 단계에서 적절한 레벨을 유지하여 왜곡이나 노이즈를 방지합니다.\n\n모니터링 시스템\n\n인이어 모니터(In-Ear Monitor) 와 모니터 스피커를 통해 아티스트에게 맞춤형 모니터 믹스를 제공합니다.\n모니터 믹스의 신호 흐름을 정확히 이해하여 피드백을 방지하고 아티스트의 요구를 충족시킵니다.\n\n결론\n시그널 플로우는 음향 시스템의 핵심이며, 이를 정확히 이해하고 관리하는 것은 시니어 사운드 엔지니어로서의 필수 역량입니다. 신호가 시스템 내에서 어떻게 이동하고 처리되는지를 알고, 각 단계에서 무엇을 체크해야 하는지를 명확히 함으로써 안정적이고 높은 품질의 사운드를 구현할 수 있습니다. 지속적인 학습과 실무 경험을 통해 시그널 플로우에 대한 이해를 깊게 하고, 이를 바탕으로 전문적인 엔지니어링을 수행하시기 바랍니다."},"Sound/음향-(Sound)":{"title":"음향 (Sound)","links":["Sound/신호-흐름-(Signal-Flow)","Sound/게인-스트럭처(Gain-Structure)"],"tags":["GainStructure"],"content":"\n신호 흐름 (Signal Flow)\n게인 스트럭처(Gain Structure)\n"},"Sound/하울링(Feedback)":{"title":"하울링(Feedback)","links":["이퀄라이제이션-(Equalization)","tags/AudioProcessing","음향-게인-(Acoustic-Gain)","tags/SoundReinforcement","마이크-지향성-(Microphone-Directionality)","tags/MicrophoneTechniques","룸-어쿠스틱스-(Room-Acoustics)","tags/AcousticDesign","피드백-서프레서-(Feedback-Suppressor)","tags/AudioEquipment"],"tags":["SoundEngineering","AudioFeedback","Acoustics","LiveSound","SignalProcessing","terminology","AudioProduction","AudioProcessing","SoundReinforcement","MicrophoneTechniques","AcousticDesign","AudioEquipment"],"content":"오디오 피드백 (Audio Feedback)\nWhat is Audio Feedback\n\n\n정의 (Definition):\n\n오디오 피드백은 음향 출력(예: 스피커)과 입력(예: 마이크) 사이에 음향 경로가 존재할 때 발생하는 양의 피드백 상황입니다. 이는 스피커에서 나온 소리가 마이크로 다시 입력되어 증폭되는 순환 과정을 만들어 특징적인 ‘하울링’ 소리를 발생시킵니다(Wikipedia, 2024).\n피드백은 마이크, 앰프, 스피커의 공진 주파수, 공간의 음향 특성, 마이크와 스피커의 방향성 픽업 및 방출 패턴, 그리고 이들 간의 거리에 의해 결정됩니다(Wikipedia, 2024).\n\n\n\n예시 (Examples):\n\n공연장에서 마이크를 스피커에 너무 가까이 가져갔을 때 발생하는 날카로운 소리.\n전기 기타를 앰프 가까이에 두어 의도적으로 만들어내는 지속음.\n회의실에서 마이크와 스피커 시스템이 부적절하게 설정되어 발생하는 불쾌한 소음.\n\n\n\nLiterature Review\nClark, 2005\n\nWhat causes feedback in a guitar or microphone?\n\nSource: Scientific American\n\n\n주요 내용 (Key points):\n\n피드백은 입력과 출력 사이의 ‘루프’가 닫힐 때 발생합니다.\n게인(증폭 수준)은 피드백 발생에 중요한 요소입니다.\n이퀄라이저를 사용하여 문제가 되는 주파수를 조절함으로써 피드백을 제어할 수 있습니다.\n악기(예: 기타)의 구조적 진동도 피드백에 영향을 줄 수 있습니다.\n\n\n\nMediaCollege.com, n.d.\n\nHow to Eliminate Feedback\n\nSource: MediaCollege.com\n\n\n주요 내용 (Key points):\n\n마이크와 스피커의 위치 조정이 피드백 방지의 핵심입니다.\n지향성 마이크 사용, 마이크에 가까이 대고 말하기, 사용하지 않을 때 마이크 끄기 등의 방법을 제안합니다.\n이퀄라이저를 사용하여 피드백을 유발하는 주파수를 낮추는 것이 효과적입니다.\n노이즈 게이트나 필터 사용, 스피커 출력 낮추기 등의 추가적인 방법도 소개합니다.\n\n\n\n관련 개념 (Related Concepts)\n\n이퀄라이제이션 (Equalization)AudioProcessing\n\n특정 주파수를 조절하여 피드백을 제어하는 중요한 기술입니다.\n\n\n음향 게인 (Acoustic Gain)SoundReinforcement\n\n피드백이 발생하기 전에 얻을 수 있는 최대 음량을 결정하는 요소입니다.\n\n\n마이크 지향성 (Microphone Directionality)MicrophoneTechniques\n\n마이크의 픽업 패턴이 피드백 발생에 영향을 미칩니다.\n\n\n룸 어쿠스틱스 (Room Acoustics)AcousticDesign\n\n공간의 음향 특성이 피드백 발생에 중요한 역할을 합니다.\n\n\n피드백 서프레서 (Feedback Suppressor)AudioEquipment\n\n자동으로 피드백을 감지하고 억제하는 장치입니다.\n\n\n"},"Sound/하이패스-필터(High-Pass-Filter)":{"title":"하이패스 필터(High-Pass Filter)","links":["로우패스-필터-(Low-Pass-Filter)","tags/LowPassFilter","밴드패스-필터-(Band-Pass-Filter)","tags/BandPassFilter","노치-필터-(Notch-Filter)","tags/NotchFilter","파라메트릭-EQ-(Parametric-Equalizer)","tags/ParametricEQ","크로스오버-(Crossover)","tags/Crossover"],"tags":["AudioEngineering","SignalProcessing","SoundDesign","Equalization","FrequencyResponse","terminology","HighPassFilter","LowPassFilter","BandPassFilter","NotchFilter","ParametricEQ","Crossover"],"content":"하이패스 필터 (High-Pass Filter)\nWhat is High-Pass Filter\n\n정의 (Definition):\n\n하이패스 필터(HPF)는 설정된 차단 주파수(cutoff frequency) 아래의 모든 주파수를 감쇠시키는 이퀄라이제이션 도구입니다. 즉, 고주파는 통과시키고 저주파는 제거합니다(Mathias, n.d.).\n하이패스 필터는 오디오 기술의 거의 모든 응용 분야에서 사용되며, 믹싱 콘솔, 디지털 오디오 워크스테이션(DAW), 일부 마이크로폰에 내장되어 있습니다(Mathias, n.d.).\n\n\n예시 (Examples):\n\n남성 보컬에서 80Hz 이하의 불필요한 저주파를 제거하기 위해 하이패스 필터를 사용합니다(Mathias, n.d.).\n라이브 사운드에서 마이크 핸들링 노이즈를 줄이기 위해 하이패스 필터를 적용합니다(Mathias, n.d.).\n킥 드럼과 베이스 기타의 주파수 충돌을 방지하기 위해 하이패스 필터로 주파수 대역을 조절합니다(Mathias, n.d.).\n\n\n\nLiterature Review\nMathias, n.d.\n\nWhat Are Audio HIGH PASS FILTERS &amp; How to Use Them\n\nSource: Audio University Online\n\n\n주요 내용 (Key points):\n\n하이패스 필터의 기본 개념과 작동 원리를 설명합니다.\n하이패스 필터의 주요 설정인 차단 주파수(cutoff frequency)와 기울기(slope/Q)에 대해 상세히 설명합니다.\n하이패스 필터의 9가지 주요 사용 사례를 제시하고 각각에 대해 설명합니다.\n\n\n\nFox, n.d.\n\nAudio EQ: What Is A High-Pass Filter &amp; How Do HPFs Work?\n\nSource: My New Microphone\n\n\n주요 내용 (Key points):\n\n하이패스 필터의 기술적 측면과 주파수 응답 특성을 자세히 설명합니다.\n다양한 오디오 장비와 소프트웨어에서 하이패스 필터의 구현 방식을 다룹니다.\n하이패스 필터의 실제 적용 사례와 팁을 제공합니다.\n\n\n\n관련 개념 (Related Concepts)\n\n로우패스 필터 (Low-Pass Filter)LowPassFilter\n\n하이패스 필터와 반대로 작동하며, 설정된 차단 주파수 위의 주파수를 감쇠시킵니다.\n\n\n밴드패스 필터 (Band-Pass Filter)BandPassFilter\n\n특정 주파수 대역만 통과시키고 나머지는 감쇠시키는 필터로, 하이패스와 로우패스 필터의 조합으로 볼 수 있습니다.\n\n\n노치 필터 (Notch Filter)NotchFilter\n\n특정 주파수 대역만을 제거하는 필터로, 하이패스 필터와 함께 사용하여 더 정밀한 주파수 조절이 가능합니다.\n\n\n파라메트릭 EQ (Parametric Equalizer)ParametricEQ\n\n하이패스 필터를 포함한 여러 유형의 필터를 조합하여 사용할 수 있는 고급 이퀄라이제이션 도구입니다.\n\n\n크로스오버 (Crossover)Crossover\n\n스피커 시스템에서 하이패스 필터와 로우패스 필터를 사용하여 주파수 대역을 분할하는 기술입니다.\n\n\n"},"Terminology-generating-workflow-with-Obsidian-and-Generative-AI":{"title":"Terminology generating workflow with Obsidian and Generative AI","links":["Perplexity","Obsidian-Plugin---Templater","Gemini","T03---Research-Terminology","2024-08-06","@구요한"],"tags":["post/medium"],"content":"General Terminology\n\nPerplexity + Obsidian Plugin - Templater\n\nwhen we learn new fields, we need to know the terminology. There is way to make terminology easier with obsidian avoiding halluciations\nFirst, find terminology by using an AI search tool like Perplexity. Then, copy the result and paste to generative AI such as Gemini and chatGPT using template\nPerplexity gives you result based on reference and chatGPT change your appropriate template.\nResearch Terminology\n\nT03 - Research Terminology\n\nShare Obsidian &amp;&amp; AI workflow\nThis is way to make a terminology for research!\nFirst, search for the terminology using consensus gpts,an AI-powered research tool.\nThen, copy the result and paste it into a template for chatGPT\nconsensus provides you result based on academic article,helping you avoid halluciations.\nchatGPT will generate you terminology note :)\nThinking\n\n2024-08-06 21:38 Reference : @구요한\n2024-08-06 21:50 easier 잘 못스네\n"},"Zotero-7-hookmark-동작-안하는-것-해결-방법":{"title":"Zotero 7 hookmark 동작 안하는 것 해결 방법","links":["조테로-(Zotero)","Hookmark"],"tags":["zotero","post/medium"],"content":"I’m currently using Zotero for my research, Zotero is free and easy to use.\nThis week, I upgraded to Zotero 7 beta because it has a better design than the previous version. However, when I launched the new Zotero and tried to use Hookmark to connect the Obsidian vault with Zotero, Hookmark was not working.\nToday, I will share how I solved this problem\nZotxt Extension\nGo to the zotxt GitHub page. Download Zotxt suitable for your version of Zotero. Install zotxt by following the instructions on the its GitHub page.\nZotxt is a Zotero extension for supporting utilities that deal with plain text files (e.g., markdown, reStructuredText, latex, etc.) This plugin will be used for Hookmark required text to make hookmark link\nZotero-markdown-translator\nGo to the silentdot/zotero-markdown-translator GitHub page. download the Zotero translator from the repository. Then install the translator by following the instructions provided on the Github page.\nThe Zotero Markdown Translator plugin creates Markdown links when exporting. To solve my problem, I needed to change the Item Format to Markdown Item URI\n\nGo to the Export tab.\nSet the Item Format to Markdown Item URI.\nThis ensures that your exported items are in the correct format for Markdown.\n\nConclusion\n\nFinally, reboot Zotero and check if the problem is solved. If you need further information,The latest discussions around Zotero 7 beta and its compatibility with Hookmark can be found here. It includes updates on potential issues and fixes related to Hookmark."},"index":{"title":"Home","links":["아버지를-존경할-이유","Javascript-Asynchronous-Programming","음향-엔지니어가-Javascript-Concurrency-Vs-Parallelism-이해하는-방법","음향-엔지니어가-JavaScript의-실행-메커니즘-이해하는-방법"],"tags":[],"content":"\nSample\n\n아버지를 존경할 이유\nJavascript Asynchronous Programming\n\n음향 엔지니어가 Javascript Concurrency Vs Parallelism 이해하는 방법\n음향 엔지니어가 JavaScript의 실행 메커니즘 이해하는 방법\n\n\n\n\n\n"},"검색-엔진-Obsidian-plugin-Omnisearch-연동하기":{"title":"검색 엔진 Obsidian plugin Omnisearch 연동하기","links":[],"tags":["Omnisearch","검색엔진","Obsidian","Browser","연결","article","post/tistory"],"content":"검색엔진 Obsidian Plugin Omnisearch 연동하기\nOmnisearch는 Obsidian의 강력한 검색 플러그인으로, 다음과 같은 특징을 가지고 있습니다:\n\n다양한 파일 형식 지원: 노트, Office 문서, PDF, 이미지 등을 빠르게 검색\n오타 저항성: 검색어의 오타에도 관련 결과를 찾아냄\n필터링 기능: 다양한 파일 형식별 필터링 가능\n키보드 중심 워크플로우: 효율적인 검색 및 탐색 지원\n외부 접근성: 로컬 HTTP 서버를 통해 Obsidian 외부에서도 쿼리 가능\n\nOmnisearch를 브라우저와 연동하면 다음과 같은 이점을 얻을 수 있습니다:\n\n통합 검색 경험: 웹 검색과 개인 노트 검색을 동시에 수행\n지식 연결: 외부 정보와 개인 지식을 쉽게 연결\n맥락 이해 향상: 검색 결과의 맥락을 더욱 풍부하게 이해\n노트 활용도 증가: 개인 노트의 활용 빈도와 가치 상승\n시간 절약: 여러 플랫폼을 오가며 검색할 필요 없이 한 곳에서 모든 정보 접근\n아이디어 발견: 웹 정보와 개인 노트를 동시에 보며 새로운 연결점 발견 가능\n\n이 가이드에서는 Omnisearch를 브라우저와 연동하는 방법을 단계별로 안내하여, 사용자가 이러한 장점들을 최대한 활용할 수 있도록 돕습니다.\nOmnisearch를 Google/Kagi에 연결하는 방법\n\n\nOmnisearch의 최신 버전을 Obsidian에 설치하고, 설정에서 HTTP 서버를 활성화합니다.\n\n\n\n브라우저에 Tampermonkey (또는 다른 userscript 관리자)를 설치합니다.\n\n\n\n브라우저의 Developer Mode를 활성화합니다. 브라우저별 확장 프로그램 페이지 링크:\n\nChrome: chrome://extensions/\nArc: arc://extensions/\n\n각 브라우저에서 “개발자 모드” 또는 “Developer Mode” 토글을 찾아 활성화합니다. Chrome과 Arc는 오른쪽 상단, Edge는 왼쪽 하단에 있습니다.\n\n\n이 작업을 통해 Tampermonkey를 통해 userScripts API를 사용할 수 있게 됩니다.\n\n\n선호하는 검색 엔진에 해당하는 userscript를 설치합니다, extension을 설치하고 아래 링크에 접속하면 Tampermonkey가 접근 가능하도록 할 것이냐 물어봅니다\n\nKagi\nGoogle\nDuckDuckGo\nBing\n\n\n다음은 experimental Javascript feature를 실행시켜야 합니다\n\n\nExperimental JavaScript features를 활성화합니다. 브라우저별 설정 페이지 링크:\n\nChrome: chrome://flags/#enable-experimental-web-platform-features\nArc: arc://flags/#enable-experimental-web-platform-features\n\n각 브라우저에서 “Experimental Web Platform features”를 찾아 “Enabled”로 설정합니다.\n\n\n\n\n이제 처음 구글 search를 하면, 아래와 같이 권한을 요구합니다. 여기서 Allow를 누르시면 사용하실 수 있습니다\n\n궁금증\n왜 Developer Mode를 활성화해야 하나요?\nDeveloper Mode는 userscript의 두 단계 사용자 권한 부여를 위해 필요합니다: userScripts 권한과 Developer Mode 옵션입니다. userScripts 권한만으로는 설치 시 사용자 경고를 트리거하지 않습니다. 따라서 이 추가 단계는 사용자가 Userscripts를 사용하는 확장 프로그램을 실행하는 데 있어 신중한 결정을 내리도록 하기 위한 Google의 의도를 반영합니다.\nOmnisearch와 브라우저 연동의 동작 원리\n\n로컬 HTTP 서버: Omnisearch 플러그인은 Obsidian 내에서 로컬 HTTP 서버를 실행합니다. 이 서버는 외부 애플리케이션(이 경우 브라우저)에서 Obsidian 노트를 검색할 있게 해줍니다.\nUserscript: Tampermonkey를 통해 설치된 userscript는 브라우저의 검색 결과 페이지에 삽입됩니다. 이 스크립트는 사용자의 검색 쿼리를 감지합니다.\nAPI 요청: userscript는 감지한 검색 쿼리를 사용하여 Omnisearch의 로컬 HTTP 서버에 API 요청을 보냅니다.\n결과 처리: Omnisearch 서버는 요청을 처리하고, Obsidian 노트에서 관련된 결과를 찾아 반환합니다.\n결과 표시: userscript는 받은 결과를 처리하여 브라우저의 검색 결과 페이지에 Obsidian 노트의 검색 결과를 삽입합니다.\n"},"글또-작성-마감-일정-(공유용)---Obsidian-version":{"title":"글또 작성 마감 일정 (공유용) - Obsidian version","links":["Obsidian-Plugin---Dataview"],"tags":["Technology","Software","DataManagement"],"content":"채정님의 작성 마감 일정(공유용)을 Obsidian version으로 변환하였습니다!\nDataview 기능 설명\nDataview는 Obsidian에서 메타데이터를 쿼리하고 표시하는 강력한 플러그인입니다. 주요 기능은 다음과 같습니다:\n\n메타데이터 인덱싱: 태그, YAML 프론트매터, 인라인 필드 등을 자동으로 인덱싱합니다.\n쿼리 실행: 인덱싱된 데이터를 기반으로 다양한 쿼리를 실행할 수 있습니다.\n동적 뷰 생성: 쿼리 결과를 테이블, 리스트, 작업 목록 등 다양한 형태로 표시할 수 있습니다.\n\n사용 방법\n\nObsidian Plugin - Dataview를 설치합니다.\n글감 노트에 #글또/글감 태그를 추가합니다.\n아래 코드 블록을 원하는 노트에 붙여넣습니다:\n\nTABLE default(title, &quot;No Title&quot;) as &quot;글 제목&quot;, default(deadLine, &quot;No date&quot;) as &quot;마감일&quot;, filter(tags, (t) =&gt; t != &quot;글또/글감&quot;) as &quot;Tags&quot;\nFROM #글또/글감\n실제 예시\n이제 글감이 아래와 같이 dataview에 뜨는 것을 볼 수 있습니다, 제목이 길어서 짤렸지만 Tag도 같이 출력 됩니다 :)\n\n커스터마이징 옵션\nDataview 쿼리를 더욱 개선하고 싶다면 다음과 같은 옵션을 고려해볼 수 있습니다:\n\n\n정렬: SORT 명령어를 사용하여 결과를 정렬할 수 있습니다.\nTABLE default(title, &quot;No Title&quot;) as &quot;글 제목&quot;, default(deadLine, &quot;No date&quot;) as &quot;마감일&quot;, filter(tags, (t) =&gt; t != &quot;글또/글감&quot;) as &quot;Tags&quot;\nFROM #글또/글감\nSORT deadLine ASC\n\n\n필터링: WHERE 절을 사용하여 특정 조건에 맞는 결과만 표시할 수 있습니다.\nTABLE default(title, &quot;No Title&quot;) as &quot;글 제목&quot;, default(deadLine, &quot;No date&quot;) as &quot;마감일&quot;, filter(tags, (t) =&gt; t != &quot;글또/글감&quot;) as &quot;Tags&quot;\nFROM #글또/글감\nWHERE date(deadLine) &gt;= date(today)\n\n\n그룹화: GROUP BY를 사용하여 결과를 그룹화하고 각 그룹 내의 파일들을 리스트업할 수 있습니다.\nTABLE \n  rows.file.link AS &quot;글 제목&quot;,\n  rows.deadLine AS &quot;마감일&quot;,\n  rows.file.tags AS &quot;Tags&quot;\nFROM #글또/글감\nGROUP BY dateformat(date(deadLine), &quot;yyyy-MM&quot;) AS &quot;월&quot;\nSORT 월 ASC\n\n\n계산 필드: JavaScript 표현식을 사용하여 계산된 필드를 추가할 수 있습니다.\nTABLE default(title, &quot;No Title&quot;) as &quot;글 제목&quot;, default(deadLine, &quot;No date&quot;) as &quot;마감일&quot;, filter(tags, (t) =&gt; t != &quot;글또/글감&quot;) as &quot;Tags&quot;, date(deadLine) - date(today) as &quot;남은 일수&quot;\nFROM #글또/글감\n\n\n더 많은 커스터마이징 옵션과 고급 기능은 Dataview 공식 문서를 참조하세요. Dataview의 쿼리 언어(DQL)와 JavaScript API를 활용하면 더욱 복잡하고 강력한 데이터 뷰를 만들 수 있습니다."},"아버지를-존경할-이유":{"title":"아버지를 존경할 이유","links":[],"tags":["Family","Ethics","Business"],"content":"아빠한테 전화해서 존경한다고 말씀드렸다\n아버지라 부르지는 않지만, 호칭에 상관 없이 암튼 존경한다\n왜냐면, 아버지이기 때문이다, 그 무거운 이름을 짊어진 것이 정말 멋진 것임을 점점 느낀다\n최근에 책을 통해 사기를 당하면, 비가역적인 손상을 입을 수 있고,\n그 처벌 또한 시원하게 할 수 없는 경우가 잦다는 것을 알게 되었다\n왜냐면, 우리의 도덕과 법이 완전히 일치하지 않기 때문이다\n그런데, 그런 위험을 이겨내고 살아남아서 우리 가족을 지켜내셨고, 삶을 포기하지 않으셨다\n또, 어렸을 때부터 귀에 못이 박히도록,\n슬리퍼 신지 말고, 옷과 머리는 단정히 깔끔하게 다녀야 한다\n진짜 매일 말씀하셨는데, 이젠 그 말이 이해가 된다.\n아무렴 그 반대의 것을 잔뜩 누리면서 살았지만야\n분명히 드레스 코드는 많은 것을 드러내는 지표로 사용 되기 때문에\n단정하고, 깔끔한 외관이 여러모로 도움이 될 상황이 많은거 같다. 전략적으로 사용 될 수 있다\n사업하시는 아빠 입장에서 드레스 코드가 내포하는 의미가 무엇인지 알고 있기 때문에 그러셨겠군 싶다\n항상 강조하시는 사람을 만나면 무조건 인사 잘해야 한다.\n처음 보면 안녕하세요, 그 날 여러번 마주치면 싱긋 웃으면서 목례를 하라했던 것도 이해가 된다\n이해가 되는 요즘이다, 단순한 문장 뒤에 숨은 복잡한 백그라운드가 있음을 느낀다\n기회가 되면, 그 이야기를 들어보고 싶다아"},"음향-엔지니어가-JavaScript의-실행-메커니즘-이해하는-방법":{"title":"음향 엔지니어가 JavaScript의 실행 메커니즘 이해하는 방법","links":[],"tags":["음향","Technology","Programming","Music"],"content":"JavaScript의 실행 메커니즘 이해하기 - 사운드 엔지니어를 위한 안내서\nJavaScript는 싱글 스레드 언어로, 동기와 비동기 코드를 효율적으로 처리하기 위해 콜 스택, 이벤트 루프, 그리고 태스크 큐를 사용합니다. 이 글에서는 사운드 엔지니어의 작업 흐름을 비유로 들어 JavaScript의 실행 메커니즘을 쉽게 이해할 수 있도록 설명하겠습니다.\n콜 스택(Call Stack)\n🎛️ 믹싱 콘솔의 현재 작업 채널\n콜 스택은 현재 실행 중인 함수들이 쌓이는 공간입니다. 이는 마치 사운드 엔지니어가 믹싱 콘솔에서 특정 채널을 조작하는 것과 같습니다. 엔지니어는 한 번에 하나의 채널에 집중하여 EQ 조정, 이펙트 적용 등의 작업을 수행합니다. 작업이 완료되면 다음 채널로 넘어가죠.\n예를 들어, 보컬 트랙의 EQ를 조정하는 동안에는 다른 트랙을 건드리지 않습니다. 이처럼 콜 스택은 현재 처리 중인 작업의 순서를 관리하며, 상위에 있는 작업이 완료되면 그 아래의 작업을 이어서 처리합니다.\n이벤트 루프(Event Loop)\n🔄 작업 스케줄러의 역할\n이벤트 루프는 콜 스택과 태스크 큐를 관리하여 비동기 작업이 언제 실행될지 결정하는 역할을 합니다. 이는 사운드 엔지니어의 어시스턴트가 작업 스케줄을 관리하며, 엔지니어가 현재 작업을 마치면 다음에 어떤 작업을 해야 할지 알려주는 것과 비슷합니다.\n어시스턴트는 긴급한 작업과 일반 작업을 구분하여 우선순위를 정합니다. 긴급한 수정 사항이 있으면 즉시 엔지니어에게 알리고, 일반적인 작업은 예정된 순서에 따라 안내합니다. 이벤트 루프도 이와 같이 마이크로태스크와 매크로태스크를 구분하여 처리합니다.\n태스크 큐(Task Queue)\n📋 작업 대기 목록\n태스크 큐는 비동기 작업의 콜백 함수들이 대기하는 곳입니다. 이는 엔지니어가 앞으로 처리해야 할 작업 목록과 같습니다. 태스크 큐는 우선순위에 따라 마이크로태스크 큐와 매크로태스크 큐로 나뉩니다.\n마이크로태스크 큐(Microtask Queue)\n마이크로태스크 큐는 긴급하게 처리해야 하는 작은 작업들이 대기하는 곳입니다. 예를 들어, 믹싱 중에 발견된 작은 노이즈 제거나 즉각적인 페이드 인/아웃 작업이 여기에 해당합니다. 이러한 작업은 우선적으로 처리되어야 하므로 이벤트 루프는 마이크로태스크 큐를 먼저 확인합니다.\n매크로태스크 큐(Macro Task Queue)\n매크로태스크 큐는 일반적인 작업들이 대기하는 곳입니다. 예를 들어, 기타 트랙에 리버브를 적용하거나 드럼 트랙의 컴프레서를 조정하는 등의 예정된 작업이 여기에 포함됩니다. 마이크로태스크가 모두 처리된 후에야 매크로태스크가 실행됩니다.\n음향 예시로 보는 JavaScript 실행 흐름\n🎚️ 믹싱 콘솔에서의 작업 (JavaScript 런타임 환경)\n당신은 대형 믹싱 콘솔 앞에 앉아 있습니다. 이 콘솔이 바로 JavaScript 런타임 환경입니다.\n1. 메인 트랙 작업 시작 (전역 실행 컨텍스트 생성)\n믹싱 세션을 시작하면서 메인 페이더를 조정합니다. (JavaScript 코드 실행이 시작되고 전역 실행 컨텍스트가 생성되어 콜 스택에 푸시됩니다.)\n2. 보컬 EQ 조정 (함수 호출)\n보컬 채널의 EQ를 조정하기 위해 해당 섹션으로 이동합니다. (함수가 호출되면 새로운 실행 컨텍스트가 생성되어 콜 스택에 푸시됩니다.)\nfunction adjustVocalEQ() {\n    // EQ 조정 로직\n}\nadjustVocalEQ();\n3. 비동기 작업 요청 (비동기 API 호출)\nEQ를 조정하면서 동시에 어시스턴트에게 “기타에 리버브 추가”와 “노이즈 제거” 작업을 요청합니다. (비동기 함수들이 호출되고, Web API에 작업이 등록됩니다.)\nsetTimeout(() =&gt; addReverbToGuitar(), 0); // 매크로태스크\nPromise.resolve().then(() =&gt; removeNoise()); // 마이크로태스크\n4. 보컬 EQ 조정 완료 (함수 실행 완료)\n보컬 EQ 조정을 마치고 해당 채널에서 손을 뗍니다. (함수 실행이 완료되고 해당 실행 컨텍스트가 콜 스택에서 제거됩니다.)\n5. 어시스턴트의 작업 확인 (이벤트 루프 동작)\n잠시 콘솔에서 손을 떼고 어시스턴트를 바라봅니다. 어시스턴트는 요청받은 작업들의 우선순위를 확인하고 있습니다. (이벤트 루프가 콜 스택이 비었는지 확인하고, 태스크 큐를 검사합니다.)\n6. 긴급 노이즈 제거 작업 (마이크로태스크 실행)\n어시스턴트가 “노이즈 제거 작업이 긴급합니다!”라고 알려줍니다. 즉시 노이즈 제거 작업을 수행합니다. (마이크로태스크 큐의 작업이 콜 스택으로 이동하여 실행됩니다.)\nfunction removeNoise() {\n    // 노이즈 제거 로직\n}\n7. 기타 리버브 추가 (매크로태스크 실행)\n노이즈 제거 후, 어시스턴트가 “이제 기타에 리버브를 추가할 차례입니다”라고 안내합니다. 기타 채널로 이동하여 리버브를 추가합니다. (매크로태스크 큐의 작업이 콜 스택으로 이동하여 실행됩니다.)\nfunction addReverbToGuitar() {\n    // 리버브 추가 로직\n}\n8. 새로운 작업 확인 (이벤트 루프 반복)\n리버브 추가를 마치고 다시 어시스턴트를 바라봅니다. 새로운 작업이 있는지 확인합니다. (이벤트 루프가 다시 태스크 큐를 확인하며 새로운 작업이 있는지 검사합니다.)\n🔄 반복 과정\n이러한 과정이 계속 반복되면서 모든 믹싱 작업이 순차적으로, 그리고 효율적으로 처리됩니다. (JavaScript 런타임은 이벤트 루프를 통해 비동기 작업들을 관리하며 싱글 스레드에서 동시성을 구현합니다.)\n이 과정을 통해 복잡한 믹싱 작업(JavaScript 프로그램)이 체계적으로 진행되며, 긴급한 작업(마이크로태스크)과 일반 작업(매크로태스크)이 적절히 처리되는 것을 볼 수 있습니다.\n💻 코드 예시와 비교\nconsole.log(&#039;보컬 트랙 EQ 조정 시작&#039;); // 동기 작업\n \nsetTimeout(() =&gt; {\n  console.log(&#039;기타 트랙 리버브 적용&#039;); // 매크로태스크\n}, 0);\n \nPromise.resolve().then(() =&gt; {\n  console.log(&#039;노이즈 제거&#039;); // 마이크로태스크\n});\n \nconsole.log(&#039;보컬 트랙 EQ 조정 완료&#039;); // 동기 작업\n출력 결과:\n보컬 트랙 EQ 조정 시작\n보컬 트랙 EQ 조정 완료\n노이즈 제거\n기타 트랙 리버브 적용\n\n\n동기 작업: ‘보컬 트랙 EQ 조정 시작’과 ‘보컬 트랙 EQ 조정 완료’는 즉시 실행됩니다.\n마이크로태스크: ‘노이즈 제거’는 긴급한 작업으로, 동기 작업이 완료된 후 바로 실행됩니다.\n매크로태스크: ‘기타 트랙 리버브 적용’은 예정된 작업으로, 마이크로태스크가 모두 처리된 후 실행됩니다.\n\n정리\nJavaScript의 실행 메커니즘은 사운드 엔지니어의 작업 흐름과 유사합니다.\n\n콜 스택은 현재 집중하여 처리하는 작업입니다.\n이벤트 루프는 작업의 순서를 관리하여 다음에 어떤 작업을 처리할지 결정합니다.\n태스크 큐는 대기 중인 작업들의 목록이며, 우선순위에 따라 마이크로태스크와 매크로태스크로 나뉩니다.\n\n마이크로태스크: 즉각적으로 처리해야 하는 긴급한 작업들입니다.\n매크로태스크: 예정된 일반 작업들입니다.\n\n\n"},"음향-엔지니어가-Javascript-Concurrency-Vs-Parallelism-이해하는-방법":{"title":"음향 엔지니어가 Javascript Concurrency Vs Parallelism 이해하는 방법","links":[],"tags":["ComptuerScience/동시성","병렬성","JavaScript"],"content":"동시성 (Concurrency)\n동시성은 여러 작업이 논리적으로 동시에 진행되는 것을 의미합니다. JavaScript에서는 단일 스레드로 동작하지만, 이벤트 루프를 통해 동시성을 구현합니다.\n비유: 믹싱 콘솔에서의 여러 트랙 관리\n라이브 공연 중 사운드 엔지니어는 믹싱 콘솔을 통해 여러 악기와 보컬의 소리를 조절합니다. 하지만 두 손으로 한 번에 하나의 노브(knob)나 페이더(fader)만 조작할 수 있습니다. 그럼에도 불구하고 빠르게 여러 컨트롤을 번갈아 가며 조작하여 전체적인 사운드를 조화롭게 유지합니다.\n\n여기서 사운드 엔지니어가 여러 트랙을 관리하는 것은 JavaScript의 동시성에 해당합니다.\n각각의 노브 조작은 단일 스레드의 작업이고, 이를 빠르게 번갈아 가며 조작하는 것은 비동기 작업 처리입니다.\n\n이벤트 루프\n\n이벤트 루프(Event Loop) 는 JavaScript에서 비동기 작업을 관리하는 메커니즘입니다.\n이는 사운드 엔지니어가 대기 중인 여러 사운드 조정 요청을 순서대로 처리하는 것과 비슷합니다.\n긴급한 조정은 우선 처리하고, 나머지는 차례로 처리하여 공연의 흐름을 매끄럽게 유지합니다.\n\n예시 코드:\nconsole.log(&quot;공연 시작&quot;);\n \nsetTimeout(() =&gt; console.log(&quot;리버브 적용&quot;), 0);\nsetTimeout(() =&gt; console.log(&quot;디스토션 적용&quot;), 0);\n \nPromise.resolve().then(() =&gt; console.log(&quot;볼륨 조정 1&quot;));\nPromise.resolve().then(() =&gt; console.log(&quot;볼륨 조정 2&quot;));\n \nconsole.log(&quot;공연 진행 중&quot;);\n실행 결과:\n공연 시작\n공연 진행 중\n볼륨 조정 1\n볼륨 조정 2\n리버브 적용\n디스토션 적용\n\n설명:\n\n볼륨 조정(Promise) 은 즉각적으로 필요한 작업이므로 먼저 처리됩니다.\n이펙트 적용(setTimeout) 은 조금 뒤에 처리해도 되므로 나중에 실행됩니다.\n이는 사운드 엔지니어가 긴급한 볼륨 조정을 먼저 하고, 이후에 이펙트 적용을 수행하는 것과 같습니다.\n\n\n병렬성 (Parallelism)\n병렬성은 여러 작업이 물리적으로 동시에 진행되는 것을 의미합니다. JavaScript에서는 Web Workers를 통해 제한적인 병렬 처리가 가능합니다.\n비유: 메인 엔지니어와 어시스턴트의 협업\n대형 공연에서 사운드 엔지니어는 모든 작업을 혼자 처리하기 어렵기 때문에 어시스턴트 엔지니어와 함께 작업합니다.\n\n메인 엔지니어는 전체 믹스를 관리하고, 어시스턴트 엔지니어는 특정 악기의 이펙트나 모니터링을 담당합니다.\n두 엔지니어는 동시에 작업하며, 필요한 경우 서로 통신하여 공연의 음향을 최적화합니다.\n\n여기서:\n\n메인 엔지니어는 메인 스레드에 해당합니다.\n어시스턴트 엔지니어는 Web Worker에 해당합니다.\n서로 독립적으로 작업하지만, **메시지(통신)**를 통해 협업합니다.\n\nWeb Workers의 작동 방식\n\nWeb Worker는 메인 스레드와 분리된 실행 환경에서 동작하는 스레드입니다.\nCPU 집약적인 작업을 별도로 처리하여 메인 스레드의 응답성을 유지합니다.\n메시지 전달을 통해 메인 스레드와 데이터를 주고받습니다.\n\n예시 코드:\nmain.js\nconsole.log(&quot;메인 엔지니어 작업 시작&quot;);\n \nconst worker = new Worker(&#039;worker.js&#039;);\n \nworker.onmessage = function(event) {\n  console.log(&#039;어시스턴트로부터 받은 결과:&#039;, event.data);\n};\n \nworker.postMessage(&#039;이펙트 처리 요청&#039;);\n \nconsole.log(&quot;메인 엔지니어 작업 계속 진행&quot;);\nworker.js\nself.onmessage = function(event) {\n  console.log(&#039;어시스턴트가 받은 메시지:&#039;, event.data);\n  // 복잡한 이펙트 처리 시뮬레이션\n  const result = &#039;이펙트 처리 완료&#039;;\n  self.postMessage(result);\n};\n실행 결과:\n메인 엔지니어 작업 시작\n메인 엔지니어 작업 계속 진행\n어시스턴트가 받은 메시지: 이펙트 처리 요청\n어시스턴트로부터 받은 결과: 이펙트 처리 완료\n\n설명:\n\n메인 엔지니어는 자신의 작업을 계속하면서 어시스턴트에게 특정 작업을 맡깁니다.\n어시스턴트 엔지니어는 받은 요청을 처리하고 결과를 메인 엔지니어에게 전달합니다.\n이를 통해 동시에 여러 작업이 진행되어 공연의 품질을 높입니다.\n\n\n정리\n\n\n동시성 (Concurrency)\n\nJavaScript의 이벤트 루프를 통한 비동기 작업 처리\n사운드 엔지니어가 여러 트랙을 빠르게 조절하여 동시에 진행되는 것처럼 보이게 함\n단일 스레드에서 여러 작업을 효율적으로 관리\n\n\n\n병렬성 (Parallelism)\n\nWeb Workers를 통한 제한적인 병렬 처리\n어시스턴트 엔지니어와 메인 엔지니어가 동시에 작업을 수행\nCPU 집약적인 작업을 메인 스레드의 방해 없이 처리 가능\n\n\n"},"의존성-주입-(Dependency-Injection)":{"title":"의존성 주입 (Dependency Injection)","links":["단일-책임-원칙(Single-Responsibility-Principle)","제어의-역전(Inversion-of-Control,-IoC)","테스트-주도-개발(Test-Driven-Development,-TDD)","팩토리-패턴(Factory-Pattern)","빌더-패턴(Builder-Pattern)","싱글턴-패턴(Singleton-Pattern)","서비스-로케이터-패턴(Service-Locator-Pattern)","제어의-역전-(Inversion-of-Control,-IoC)","의존성-역전-원칙-(Dependency-Inversion-Principle,-DIP)","디자인-패턴-(Design-Pattern)","테스트-주도-개발-(Test-Driven-Development)","SOLID-원칙-(SOLID-Principles)","객체-지향-프로그래밍(Object-Oriented-Programming)"],"tags":["소프트웨어설계","디자인패턴","언어/Java","Tools/프레임워크/Spring","DependencyInjection","InversionOfControl","SoftwareDesign","DesignPatterns","SOLIDPrinciples","Testing"],"content":"의존성 주입(Dependency Injection, DI) 은 객체 지향 프로그래밍에서 객체가 자신이 필요로 하는 의존성을 직접 생성하지 않고, 외부에서 제공(주입)받는 설계 패턴이자 원칙입니다(Fowler, 2004). 여기서 의존성이란 한 객체가 다른 객체의 기능이나 데이터를 필요로 할 때 그 객체를 의미합니다. DI는 이러한 의존성을 객체 내부에서 직접 생성하지 않고, 외부에서 전달받음으로써 객체 간의 결합도를 낮추고 코드의 유연성과 재사용성을 향상시킵니다.\nDI는 다양한 프로그래밍 언어와 프레임워크에서 널리 사용되며, 객체 지향 프로그래밍의 핵심 원칙 중 하나인 단일 책임 원칙(Single Responsibility Principle) 을 준수하도록 돕습니다. 또한 DI는 제어의 역전(Inversion of Control, IoC) 원칙을 구현하는 한 가지 방법으로, 객체 생성과 의존성 관리를 애플리케이션이 아닌 외부 컨테이너나 프레임워크가 담당하게 합니다.\n왜 사용하는가 (Why Use Dependency Injection)\n\n\n결합도 감소 (Reduced Coupling): 객체가 구체적인 구현체가 아닌 인터페이스나 추상 클래스와 같은 추상화에 의존함으로써 클래스 간의 강한 결합도를 낮춥니다. 이는 코드 변경 시 영향 범위를 최소화하고, 모듈화와 재사용성을 향상시킵니다.\n\n\n테스트 용이성 (Improved Testability): 의존성을 외부에서 주입받기 때문에, 테스트 시 모의 객체(mock objects)나 스텁(stubs)을 활용하여 단위 테스트를 쉽게 수행할 수 있습니다. 이는 테스트 주도 개발(Test-Driven Development, TDD) 을 실천하는 데 큰 도움이 됩니다.\n\n\n유연성과 확장성 (Flexibility and Scalability): 런타임 시 의존성을 교체하거나 구성할 수 있어 애플리케이션의 유연성을 높입니다. 새로운 기능 추가나 변경 시 기존 코드를 최소한으로 수정하여 확장성을 제공합니다.\n\n\n가독성 및 유지보수성 향상 (Improved Readability and Maintainability): 의존성이 명시적으로 드러나기 때문에, 코드의 가독성이 향상되고 유지보수가 쉬워집니다.\n\n\n의존성을 직접 생성하는 경우\n의존성을 주입하지 않는다는 것은 객체 내부에서 필요한 의존성을 직접 생성한다는 의미이며, 이는 강한 결합(Tight Coupling) 을 초래합니다. 이러한 경우 다음과 같은 문제가 발생합니다.\n\n\n유연성 감소: 의존 대상의 구현체가 변경되면 이를 사용하는 모든 객체를 수정해야 합니다.\n\n\n테스트의 어려움: 객체 내부에서 의존성을 생성하기 때문에, 단위 테스트 시 모의 객체를 주입하기 어렵습니다.\n\n\n재사용성 저하: 특정 구현체에 종속되어 다른 컨텍스트에서 재사용하기 어렵습니다.\n\n\n코드 중복 증가: 동일한 의존성을 여러 곳에서 생성하면 코드 중복이 발생합니다.\n\n\n아래 코드는 의존성을 직접 생성하는 경우의 예시입니다.\npublic class UserService {\n    private UserRepository userRepository;\n \n    public UserService() {\n        this.userRepository = new UserRepository(); // 의존성을 직접 생성\n    }\n \n    public void performAction() {\n        userRepository.save();\n    }\n}\n위 코드에서 UserService는 UserRepository의 구체적인 구현체를 직접 생성하고 있습니다. 만약 UserRepository의 구현을 변경하거나 다른 구현체로 교체하려면 UserService 코드를 수정해야 합니다.\n반면에 의존성을 주입받게 되면, UserService는 UserRepository의 구체적인 구현에 대해 알 필요가 없으며, 필요에 따라 다른 구현체를 주입할 수 있습니다.\n어떻게 적용하는가 (How to Apply Dependency Injection)\n\n\n생성자 주입(Constructor Injection): 생성자를 통해 필요한 의존성을 주입받는 방식입니다. 의존성이 반드시 필요한 경우에 사용하며, 객체의 불변성을 유지할 수 있습니다.\npublic class UserService {\n    private final UserRepository userRepository;\n \n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n \n    public void performAction() {\n        userRepository.save();\n    }\n}\n장점:\n\n의존성이 객체 생성 시점에 주입되므로, 의존성이 누락되는 것을 방지할 수 있습니다.\nfinal 키워드를 사용하여 의존성을 불변으로 유지할 수 있습니다.\n\n단점:\n\n의존성이 많을 경우 생성자의 매개변수가 많아져 가독성이 떨어질 수 있습니다.\n\n\n\n세터 주입(Setter Injection): 세터 메서드를 통해 의존성을 주입받는 방식입니다. 선택적인 의존성이나 변경 가능한 의존성을 주입할 때 사용합니다.\npublic class UserService {\n    private UserRepository userRepository;\n \n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n \n    public void performAction() {\n        userRepository.save();\n    }\n}\n장점:\n\n의존성을 선택적으로 주입할 수 있어 유연성이 높습니다.\n필요에 따라 의존성을 변경할 수 있습니다.\n\n단점:\n\n의존성이 주입되지 않을 위험이 있어, 런타임 시 NullPointerException이 발생할 수 있습니다.\n객체 상태의 불변성을 보장하기 어렵습니다.\n\n\n\n필드 주입(Field Injection): 직접 필드에 의존성을 주입하는 방식입니다. 주로 프레임워크에서 지원하며, 리플렉션(reflection)을 사용합니다.\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n \n    public void performAction() {\n        userRepository.save();\n    }\n}\n장점:\n\n코드가 간결해집니다.\n의존성을 쉽게 주입할 수 있습니다.\n\n단점:\n\n테스트 시 의존성 주입이 어렵습니다.\n필드가 외부에서 보이지 않아 의존성을 명확히 알기 어렵습니다.\nDI 컨테이너에 종속적입니다.\n\n\n\n인터페이스 주입(Interface Injection): 특정 인터페이스를 구현하여 의존성을 주입받는 방식입니다. 의존성을 주입하기 위한 메서드를 정의해야 하므로 일반적이지 않습니다.\npublic interface UserRepositoryAware {\n    void setUserRepository(UserRepository userRepository);\n}\n \npublic class UserService implements UserRepositoryAware {\n    private UserRepository userRepository;\n \n    @Override\n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n \n    public void performAction() {\n        userRepository.save();\n    }\n}\n장점:\n\n의존성 주입 메서드를 명시적으로 정의합니다.\n\n단점:\n\n코드의 복잡성이 증가합니다.\n의존성을 위한 인터페이스를 추가로 생성해야 합니다.\nDI 컨테이너에 의존적입니다.\n\n\n\n서비스 로케이터 패턴(Service Locator Pattern): 의존성을 런타임에 검색하여 주입하는 방식입니다. 하지만 이는 DI의 원칙에 어긋나며, 코드의 가독성과 테스트 용이성을 떨어뜨릴 수 있어 일반적으로 권장되지 않습니다.\npublic class UserService {\n    private UserRepository userRepository;\n \n    public UserService() {\n        this.userRepository = ServiceLocator.getUserRepository();\n    }\n \n    public void performAction() {\n        userRepository.save();\n    }\n}\n주의사항:\n\n서비스 로케이터 패턴은 의존성을 숨기기 때문에 코드의 가독성과 유지보수성을 떨어뜨립니다.\n테스트 시 모의 객체를 주입하기 어렵습니다.\n의존성 역전 원칙(DIP)에 위배될 수 있습니다.\n\n\n\n왜 나는 DI와 퍼사드 패턴을 혼동했을까?\n초점의 차이 때문이었습니다. 두 패턴 모두 “복잡성을 줄인다”는 공통 목표를 가진다고 생각할 수 있습니다. 그러나 DI와 퍼사드 패턴(Facade Pattern) 은 서로 다른 문제를 해결하는 패턴입니다.\n퍼사드 패턴은복잡한 하위 시스템에 대한 간단한 인터페이스를 제공하여 사용자가 시스템의 내부 복잡성을 알 필요 없이 기능을 사용할 수 있게 합니다. DI(의존성 주입) 객체가 자신의 의존성을 외부에서 주입받는 방식을 정의하여 객체 간의 결합도를 낮추고, 유연성과 테스트 용이성을 향상시킵니다.\n제가 혼동한 이유는 즉 두 패턴 모두 추상화와 결합도 줄이기에 중점을 두고 있기 때문입니다. 하지만, 퍼사드 패턴은 주로 인터페이스 단순화에, DI는 객체 간 결합도 줄이기와 테스트 용이성에 초점을 맞추고 있습니다.\n각 전략의 본질을 알아봅시다. DI는 단순히 객체의 의존성을 주입하는 것이 아니라, 객체 간의 강한 결합을 느슨하게 만듭니다. 이를 통해 코드가 더 쉽게 수정되고, 유닛 테스트가 용이해집니다. 또한 시스템의 유연성을 높여 변경 사항에 유연하게 대응할 수 있게 합니다. 퍼사드의 역할: 퍼사드는 시스템의 내부 동작을 감추고 단순한 API를 제공하여 클라이언트가 복잡한 시스템을 이해할 필요 없이 쉽게 사용할 수 있게 합니다. 퍼사드가 직접적으로 의존성을 처리하는 것이 아니라, 하위 시스템의 복잡성을 감추는 데 중점을 둡니다.\n즉 두 패턴의 목적과 적용 범위가 다르다는 점을 파악해야 합니다. 퍼사드는 복잡한 하위 시스템의 상호작용을 간소화하고, DI는 시스템을 더 유연하고 테스트 가능한 구조로 만드는 데 기여합니다.\n음향 엔지니어 예시로 설명\n퍼사드 패턴은 복잡한 음향 시스템을 관리하는 하나의 단순한 인터페이스로 비유할 수 있습니다. 예를 들어, 콘서트에서 믹싱 엔지니어는 다양한 장비(마이크, 스피커, 이펙터)를 일일이 조작하지 않고, 믹싱 콘솔이라는 하나의 통합된 인터페이스를 통해 전체 시스템을 제어합니다. 이는 퍼사드가 복잡한 시스템을 간단하게 조작할 수 있게 하는 역할과 유사합니다.\n반면, DI(의존성 주입) 는 각 장비(의존성)를 외부에서 주입받아 사용하는 개념과 비슷합니다. 믹싱 엔지니어는 필요한 장비를 직접 제작하거나 연결하지 않고, 외부에서 제공되는 장비를 받아 시스템에 연결합니다. 이를 통해 장비를 교체하거나 업그레이드할 때 시스템 전체를 변경할 필요 없이 간단히 새로운 장비를 주입할 수 있습니다.\nCharacteristics and Considerations\n\n\n제어의 역전(Inversion of Control, IoC):\n\n프로그램의 제어 흐름을 개발자가 아닌 프레임워크나 컨테이너가 관리하는 원칙입니다.\nDI는 IoC의 한 구현체로서, 객체 생성과 의존성 관리를 외부로 위임합니다.\n이를 통해 객체는 자신의 핵심 로직에만 집중할 수 있습니다.\n\n\n\n의존성 역전 원칙(Dependency Inversion Principle, DIP):\n\nSOLID 원칙 중 하나로, 고수준 모듈이 저수준 모듈에 의존하지 않고, 둘 다 추상화에 의존해야 한다는 원칙입니다.\nDI를 통해 구현체가 아닌 인터페이스나 추상 클래스에 의존함으로써 이 원칙을 준수할 수 있습니다.\n이를 통해 시스템의 유연성과 확장성이 향상됩니다.\n\n\n\n단일 책임 원칙(Single Responsibility Principle, SRP):\n\n클래스는 하나의 책임만 가져야 하며, 변경 사유는 하나여야 합니다.\nDI를 활용하여 객체의 생성과 로직을 분리함으로써 이 원칙을 지킬 수 있습니다.\n객체는 자신의 책임에만 집중하고, 의존성 관리는 외부에 위임합니다.\n\n\n\n개방-폐쇄 원칙(Open/Closed Principle, OCP):\n\n소프트웨어 엔티티는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 합니다.\nDI를 통해 새로운 의존성을 주입함으로써 기존 코드를 수정하지 않고도 기능을 확장할 수 있습니다.\n\n\n\n리스코프 치환 원칙(Liskov Substitution Principle, LSP):\n\n프로그램의 객체는 그 하위 타입의 인스턴스로 대체할 수 있어야 합니다.\nDI를 사용하여 인터페이스나 추상 클래스에 의존함으로써 이 원칙을 준수할 수 있습니다.\n\n\n\n인터페이스 분리 원칙(Interface Segregation Principle, ISP):\n\n클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 합니다.\nDI를 통해 필요한 의존성만 주입받아 사용함으로써 이 원칙을 지킬 수 있습니다.\n\n\n\n주의사항:\n\n복잡성 증가: 작은 규모의 프로젝트에서 DI를 과도하게 사용하면 오히려 복잡성이 증가할 수 있습니다. 필요에 따라 적절히 적용해야 합니다.\n학습 곡선: DI 컨테이너나 프레임워크의 사용법을 숙지해야 하므로 초기 학습 비용이 발생할 수 있습니다.\n성능 고려: DI 컨테이너는 런타임 시 객체를 생성하고 주입하므로, 성능에 영향을 줄 수 있습니다. 그러나 일반적으로 이는 미미한 수준이며, 애플리케이션의 구조적 이점이 더 큽니다.\n디버깅의 어려움: 의존성이 자동으로 주입되므로, 디버깅 시 객체 생성과정이 명확하지 않을 수 있습니다.\n오버엔지니어링: 필요 이상으로 복잡한 구조를 도입하면 유지보수가 어려워질 수 있습니다.\n\n\n\nDI in Various Languages and Frameworks\n\n\nJavaScript/TypeScript:\n\nInversifyJS, TSyringe 등의 라이브러리를 사용하여 DI를 구현할 수 있습니다.\nES6 모듈과 클래스를 활용하여 간단한 DI 패턴을 적용할 수 있습니다.\n\nclass UserService {\n    constructor(private userRepository: UserRepository) {}\n \n    performAction() {\n        this.userRepository.save();\n    }\n}\n \nconst userRepository = new UserRepository();\nconst userService = new UserService(userRepository);\n\n\nPython:\n\nDependency Injector, Python Inject 등의 라이브러리를 사용하여 DI 패턴을 적용할 수 있습니다.\n\nclass UserService:\n    def __init__(self, user_repository):\n        self.user_repository = user_repository\n \n    def perform_action(self):\n        self.user_repository.save()\n \nuser_repository = UserRepository()\nuser_service = UserService(user_repository)\n\n\nDesign Patterns Related to Dependency Injection\n\n\n팩토리 패턴(Factory Pattern):\n\n객체 생성 로직을 별도의 팩토리 클래스나 메서드로 분리하여 관리합니다.\nDI 컨테이너는 내부적으로 팩토리 패턴을 사용하여 객체를 생성합니다.\nDI와 함께 사용하여 객체 생성과 의존성 주입을 효율적으로 관리할 수 있습니다.\n\n\n\n빌더 패턴(Builder Pattern):\n\n복잡한 객체의 생성 과정을 단계별로 분리하여 유연하게 객체를 생성합니다.\nDI와 함께 사용하여 객체의 구성 요소를 주입받을 수 있습니다.\n\n\n\n싱글턴 패턴(Singleton Pattern):\n\n애플리케이션에서 하나의 인스턴스만 존재해야 하는 경우에 사용됩니다.\nDI 컨테이너는 싱글턴 스코프를 지원하여 객체의 생명주기를 관리합니다.\n\n\n\n서비스 로케이터 패턴(Service Locator Pattern):\n\n의존성을 런타임에 검색하여 제공하는 패턴입니다.\n그러나 DI보다 결합도가 높고, 코드의 가독성과 테스트 용이성이 떨어지기 때문에 일반적으로 권장되지 않습니다.\n\n\n\nLimitations and Points to Consider\n\n\n과도한 추상화:\n\n인터페이스나 추상 클래스를 남발하면 코드의 복잡성이 증가하고 가독성이 떨어질 수 있습니다.\n필요한 경우에만 추상화를 도입하고, 과도한 추상화는 피해야 합니다.\n\n\n\n순환 의존성(Circular Dependency):\n\n두 개 이상의 클래스가 서로를 의존성으로 주입받을 때 발생하며, 이는 애플리케이션의 안정성을 해칩니다.\nDI 컨테이너에서 순환 의존성을 감지하고 예외를 발생시키므로, 설계를 개선하여 순환 의존성을 제거해야 합니다.\n\n\n\n런타임 에러:\n\n의존성이 누락되거나 잘못된 의존성이 주입될 경우, 컴파일 타임이 아닌 런타임에 에러가 발생할 수 있습니다.\n이를 방지하기 위해 DI 컨테이너의 설정을 철저히 검증하고, 단위 테스트를 강화해야 합니다.\n\n\n\n컨테이너 종속성:\n\nDI 컨테이너에 종속적인 코드를 작성하면, 프레임워크에 대한 의존성이 높아집니다.\n표준 애노테이션이나 인터페이스를 사용하여 컨테이너 종속성을 최소화하는 것이 좋습니다.\n\n\n\nPractical Application Cases\n\n\n대규모 애플리케이션: 복잡한 비즈니스 로직과 다수의 모듈을 가진 애플리케이션에서 DI는 코드의 유지보수성과 확장성을 크게 향상시킵니다.\n\n\n테스트 주도 개발(TDD): DI를 사용하면 모의 객체를 쉽게 주입하여 단위 테스트를 효율적으로 작성할 수 있습니다.\n\n\n플러그인 아키텍처: 의존성을 주입받아 런타임 시에 플러그인을 교체하거나 추가할 수 있습니다.\n\n\n마이크로서비스 아키텍처: 각 서비스 간의 의존성을 관리하고, 서비스 간의 결합도를 낮추는 데 도움이 됩니다.\n\n\nRelevant Concept\n\n\n제어의 역전 (Inversion of Control, IoC): IoC는 프로그램의 제어 흐름을 개발자가 아닌 프레임워크나 컨테이너가 관리하는 소프트웨어 디자인 원칙입니다. DI는 IoC를 구현하는 한 가지 방법입니다.\n\n\n의존성 역전 원칙 (Dependency Inversion Principle, DIP): 고수준 모듈이 저수준 모듈에 의존하지 않고, 추상화에 의존해야 한다는 SOLID 원칙 중 하나입니다. DI를 통해 이 원칙을 준수할 수 있습니다.\n\n\n디자인 패턴 (Design Pattern): DI는 디자인 패턴 중 하나로, 소프트웨어 개발에서 반복적으로 발생하는 문제를 해결하는 일반적인 솔루션을 제공합니다.\n\n\n테스트 주도 개발 (Test-Driven Development): DI는 테스트 가능한 코드를 작성하는 데 핵심적인 역할을 하며, TDD의 실천을 용이하게 합니다.\n\n\nSOLID 원칙 (SOLID Principles): OOP 및 설계의 다섯 가지 기본 원칙으로, DI는 이 원칙들을 준수하는 데 도움이 됩니다.\n\n\n객체 지향 프로그래밍(Object-Oriented Programming): DI는 OOP의 원칙을 효과적으로 적용하는 데 중요한 역할을 합니다.\n\n"},"조테로-(Zotero)":{"title":"조테로 (Zotero)","links":["Zotero-7-hookmark-동작-안하는-것-해결-방법"],"tags":["논문관리","참고문헌관리","인용관리","학술연구","연구도구","CitationManagement","AcademicResearch","BibliographyManagement","ResearchTools","terminology"],"content":"조테로 (Zotero)\nWhat is Zotero\n\n정의 (Definition):\n\n조테로는 연구자들이 소스를 관리하고 조직할 수 있게 도와주는 무료, 오픈 소스 참고문헌 관리 도구입니다. 사용자가 연구 자료를 수집, 정리, 인용, 공유할 수 있게 지원합니다(Center for History and New Media, 2022).\n이 도구는 연구논문 작성 시 필요한 인용문을 자동으로 생성해주고, 사용자의 라이브러리를 동기화하여 여러 장치에서 접근할 수 있게 합니다(Roy Rosenzweig Center for History and New Media, 2021).\n\n\n예시 (Examples):\n\n연구자가 논문을 작성하면서 조테로를 사용하여 참고문헌을 관리하고, 필요한 인용 스타일로 서식을 적용할 수 있습니다.\n학생이나 교수가 공동 연구 프로젝트에 참여할 때 조테로의 그룹 기능을 사용하여 자료를 공유하고 협업할 수 있습니다.\n\n\n\nPlugin\n\nMohamedElashri/awesome-zotero: A curated list of awesome Zotero resources\n\nZotero &amp;&amp; Hookmark\n\nZotero 7 hookmark 동작 안하는 것 해결 방법\n\nTranslate for Zotero\n\nwindingwind/zotero-pdf-translate: Translate PDF, EPub, webpage, metadata, annotations, notes to the target language. Support 20+ translate services.\n\nZotero is a research support tool. I recommend the Zotero plugin for translating academic articles. This plugin allows customization of settings such as auto-translation selection, auto-translation annotations, and views.\nAuto-translation selection: When a phrase is selected, it is automatically translated and the translated phrase is displayed in a pop-up.\nAuto-translation annotations: When annotations are made on a phrase, the plugin either adds the translated phrase or changes the annotations to their translated version.\nBy utilizing these features, researchers can streamline their workflow and improve the efficiency of their academic research process."},"크램폴린-IDE---NGINX-문제-해결":{"title":"크램폴린 IDE - NGINX 문제 해결","links":["🔥-Programmer","🏷️-Develop-Notes","Nginx","00.-Inbox/Notion/Campus-life/카카오-테크-캠퍼스/카카오-테크-캠퍼스","Projects/카카오테크캠퍼스/카카오-테크-캠퍼스","축팅","⚙️-Kubernetes"],"tags":["대외활동/카카오테크캠퍼스","개발/환경/에러","포스트","개발"],"content":"persona :: 🔥 Programmer\nindex :: 🏷️ Develop Notes\n#개발\n크램폴린 IDE - Nginx 문제 해결\n2023년은 카카오 테크 캠퍼스에서 교육을 받았습니다\n오늘은 카카오의 클라우드 기반 학습 관리 시스템인 크램폴린 환경에 배포하며 겪은 문제를 나누려고 합니다\nIntro. 무슨 일인가\n카카오 테크 캠퍼스 3단계 프로젝트의 주제는 축팅(네 컷 사진을 통해 축제에서 자연스러운 만남을 주선하는 서비스)이었습니다\n사진 업로드 기능을 배포 환경에서 테스트하니, Nginx 413 Request Entity Too Large 에러가 발생하였습니다\n찾아보니 기본 body size가 1M인 것을 해제하면 되는거라 금방 다시 배포를 하였습니다\n하지만,,, 문제는 해결 되지 않았죠\n\n\nNginx 413 에러란?\n\n의미 : 요청 엔티티의 크기가 너무 크다\n파일 용량이 너무 커서 디스크가 가득 차 사이트가 다운 되는 것을 방지하기 위해 설정되어있다\n\n\n\n\n원인 파악\n\n원인을 파악하기 위해서 크램폴린 배포 플로우를 다시 상기 할 필요가 있었습니다\n왜냐하면, 크램폴린 IDE에서 배포는 쿠버네티스 환경에서 진행 되기 때문입니다\nKargo를 사용하여 DKOS 클러스터에 애플리케이션을 배포하는 것을 보면 알 수 있죠\n\n\nKargo\n\n쿠버네티스 클러스터에 애플리케이션을 배포하는 도구\n지금은 Kubespray로 프로젝트 이름이 변경 되었다고 한다\n\n\n\n\n1. 쿠버네티스 환경에서 Nginx 설정이 잘못 되었는가?\n쿠버네티스 환경에서 Nginx 설정을 할 수 있는 경로는 2가지입니다\n\n인그레스 컨트롤러(ingress controller) 설정\n\nNGINX 인그레스 컨트롤러에서 어노테이션(annotation)을 통해 Nginx 설정을 적용\n\n\nNGINX 설정 커스터마이징:\n\nNGINX의 설정 파일인 nginx.conf를 직접 수정한 Pod을 생성\n\n\n\n인그레스 컨트롤러(ingress controller) 설정 조절\n쿠버네티스의 인그레스 컨트롤러는 외부 요청을 클러스터 내부 서비스로 라우팅하는 역할을 합니다.\n먼저 카카오 크램폴린에서 기본으로 제공하는 Nginx 를 사용하고, 기존의 제가 설정한 관련 Pod들을 제거하였습니다\n그 후 body size를 조정하였습니다\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: example-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/proxy-body-size: &quot;64m&quot;\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /example-path\n        pathType: Prefix\n        backend:\n          service:\n            name: example-service\n            port:\n              number: 80\n하지만,, 여전히 문제는 해결 되지 않았습니다\n2. NGINX 설정 커스터마이징\nNGINX 설정을 직접 수정하는 경우, nginx.conf 파일을 수정하여 Pod에 적용할 수 있습니다\nhttp {\n    …\n \n    client_max_body_size 64M;\n \n    …\n}\nConfigMap으로 설정을 주입하고, 직접 Nginx 이미지 패키징 할 때 설정 파일을 넣어 봤지만 여전히 문제는 해결 되지 않았습니다\n2. 로그 확인 : Hint 발견\nNginx Pod을 띄우고, 1M 이하의 이미지는 받아지지만, 용량을 초과하는 경우에 Postman에 에러를 뱉고 있으니, 이미지 크기 제한 문제가 확실했습니다\nPod 로그를 확인해보니, 다른 API 엔드 포인트에 대한 요청은 로그로 남고 있는데 413 에러가 누락 되는 것을 확인하였습니다\nNginx Pod에 사용 된 이미지의 경우, 바디 사이즈만 조절 되었기 때문에 로그가 누락 될리가 없는데 수상했습니다\nNginx 기본 Docker 이미지를 사용했다면, Nginx 에러 로그가 기록 되어야 하기 때문입니다\n왜냐하면, Nginx 이미지의 기본 로그 레벨은 error이고, 413 에러는 기본 error 레벨에서 기록 되어야하기 때문이죠\n먼가 제가 구성한 인프라의 문제가 아닐거라는 의심이 들었습니다\n3. 로컬에서 동일한 환경 구성 후 테스트\n의심되는 이미지(바디 사이즈 조절 된 기본 Nginx 이미지)를 로컬에서 테스해보았습니다\n\n재현 방법\n\n기존의 NGINX 이미지 생성 후 로컬 BE 프로젝트에 연결\n80881로 NGINX 연결하고, Postman으로 큰 이미지 전송\nNGINX 통과 후 BE 프로젝트 예외 반환 확인!\n\n\n\n\n큰 이미지가 결국 Nginx 이미지를 통과했으니, 제가 만든 이미지의 문제가 아닌거죠\n해결\n결론적으로 쿠버네티스 환경 관리자 분께 문의 드렸습니다\n확인 결과 저희 서비스 앞 단의 크램폴린에서 설정한 Nginx 문제라 판단이 되었습니다\n\n그 결과 문제 해결!\n이미지 퀄리티가 중요한 서비스에서 1M가 제한은 치명적이었고,\n팀 내에서 제가 배포를 맡고 있었어서 제 파트 문제라 스트레스를 많이 받았습니다\n이미지 제한 문제 해결하며 개발 일정이 밀리기도 했구요\n그래도 해결하니까 매우 뿌듯했습니다\n\n깨달은 점\n\n인프라 등 당연한 것들도 합리적인 의심을 할 필요가 있다\n협업 상황에서는 문제 진행 상황 공유와 적절한 시기에 시니어에게 도움을 요청하자\n\n될 때까지 잡고 늘어지다 개발 일정 밀리는 것은 일을 잘한다 할 수 없다\n\n\n\n\n\n\n  \n  \n\nTMI\n그리고, 저희 팀 카카오 테크 캠퍼스 3단계 우수조로 뽑혔습니다 올 한해 제일 짜릿한 순간이었어요\n\n궁금했던 점\nproxy_body_size와 client_max_body_size의 차이\nclient_max_body_size와 proxy_body_size는 NGINX 설정에서 비슷한 역할을 하지만, 적용되는 컨텍스트(context)에 따라 다릅니다\n\n\nclient_max_body_size:\n\n이 설정은 클라이언트로부터 직접 받은 요청의 본문 크기를 제한합니다.\nNGINX가 직접적으로 클라이언트의 요청을 처리할 때 사용됩니다.\n예를 들어, 클라이언트가 서버에 파일을 업로드하는 경우, client_max_body_size는 업로드할 수 있는 파일의 최대 크기를 제한합니다.\n\n\n\nproxy_body_size (어노테이션: nginx.ingress.kubernetes.io/proxy-body-size):\n\n이 설정은 NGINX가 프록시 서버로 동작할 때, 업스트림 서버로 전송되는 요청 본문의 크기를 제한합니다.\n주로 인그레스 컨트롤러와 같이 NGINX가 프록시 역할을 하는 경우에 사용됩니다.\n예를 들어, 인그레스 컨트롤러를 통해 내부 서비스로 요청을 전달하는 경우, 이 설정은 프록시를 통해 전달되는 요청 본문의 최대 크기를 제한합니다.\n\n\n\n결론\n\n\n직접 운영하는 NGINX 서버의 경우\n\nclient_max_body_size를 nginx.conf 파일에서 설정합니다. 이는 NGINX가 클라이언트로부터 직접 요청을 받을 때 적용됩니다.\n\n\n\n쿠버네티스 인그레스 컨트롤러 사용 시\n\nnginx.ingress.kubernetes.io/proxy-body-size 어노테이션을 사용하여 proxy_body_size를 설정합니다.\n이는 인그레스 컨트롤러를 통해 들어오는 요청에 대해 적용됩니다.\n\n\n"},"크론탭(Crontab)":{"title":"크론탭(Crontab)","links":["자동화-(Automation)","tags/Automation","스케줄링-(Scheduling)","tags/Scheduling","백업-스크립트-(Backup-Scripts)","tags/BackupScripts","로그-관리-(Log-Management)","tags/LogManagement","시스템-유지-관리-(System-Maintenance)","tags/SystemMaintenance"],"tags":["Crontab","Scheduling","Automation","Linux","TaskManagement","terminology","BackupScripts","LogManagement","SystemMaintenance"],"content":"크론탭(Crontab)\nWhat is Crontab\n\n\n정의(Definition):\n\nCrontab은 Unix 및 Linux 시스템에서 정기적인 작업을 자동으로 실행하도록 스케줄링하는데 사용되는 프로그램입니다. 크론탭 파일은 작업을 실행할 시간과 명령어를 포함하고 있으며, 시스템이 이 파일을 참조하여 작업을 수행합니다(Vixie, 1993).\n사용자는 crontab 명령어를 사용하여 크론탭 파일을 편집, 추가, 삭제할 수 있습니다. 각 작업은 일정에 따라 자동으로 실행됩니다.\n\n\n\n예시(Examples):\n\n매일 오전 3시에 /home/user/backup.sh 스크립트를 실행하여 백업을 수행합니다.\n매월 1일 오전 12시에 로그 파일을 삭제하는 명령어를 실행합니다.\n\n\n\n명령어 옵션 (Command Options)\n\ncrontab -l: 현재 사용자에 대한 Crontab의 내용을 출력합니다.\ncrontab -e: Crontab 파일을 편집할 수 있는 편집기를 엽니다.\ncrontab -r: 현재 사용자에 대한 Crontab 파일을 삭제합니다.\ncrontab -u [사용자명]: 특정 사용자의 Crontab을 관리할 수 있습니다. (관리자 권한 필요)\n\n시간 설정 (Time Setting)\nCrontab 시간 설정은 다음과 같은 5개의 필드를 사용합니다:\n\n분 (Minute): 0-59 (예: 0은 정각을 의미)\n시간 (Hour): 0-23 (예: 14는 오후 2시를 의미)\n일 (Day of the Month): 1-31 (예: 15는 매월 15일을 의미)\n월 (Month): 1-12 (예: 7은 7월을 의미)\n요일 (Day of the Week): 0-7 (0 또는 7은 일요일, 1은 월요일, 6은 토요일을 의미)\n\n예시 (Examples)\n\n0 5 * * *: 매일 오전 5시에 작업 실행.\n30 14 1 * *: 매월 1일 오후 2시 30분에 작업 실행.\n0 0 * * 0: 매주 일요일 자정에 작업 실행.\n*/10 * * * *: 매 10분마다 작업 실행.\n0 8-17 * * 1-5: 월요일부터 금요일까지 매일 오전 8시부터 오후 5시 사이에 매 정각에 작업 실행.\n잘못된 예시 (Incorrect Example): */480 * * * *\n\n설명: */480 표현은 유효하지 않습니다. 분 필드는 0에서 59 사이의 값만 허용됩니다.\n480분마다 작업을 실행하려면 시간을 기준으로 설정해야 합니다. 예를 들어, 매 8시간마다 실행하려면 0 */8 * * *로 설정해야 합니다.\n\n\n\nLiterature Review\nVixie, 1993\n\nVixie Cron\n\nSource: Usenix Proceedings\n\n\n주요 내용(Key points):\n\nCrontab의 원리와 사용 방법에 대해 설명하며, Unix 시스템에서 정기 작업을 자동화하는 크론 시스템의 기초를 설명합니다.\nCrontab 파일의 형식과 각 필드의 역할을 구체적으로 설명합니다.\n\n\n\nRay, 2020\n\nCrontab and Cron Jobs Explained\n\nSource: TechTarget\n\n\n주요 내용(Key points):\n\nCrontab의 기본 개념부터 고급 사용법까지 단계별로 설명하여, 다양한 환경에서 작업 스케줄링을 최적화하는 방법을 제시합니다.\nCrontab을 활용한 자동화 작업의 실제 사례를 통해 업무 효율성을 높이는 방법을 설명합니다.\n\n\n\n관련 개념(Related Concepts)\n\n자동화 (Automation)Automation\n\nCrontab을 사용하여 반복적인 작업을 자동화함으로써, 수동으로 수행할 필요 없이 작업이 자동으로 수행되도록 할 수 있습니다.\n\n\n스케줄링 (Scheduling)Scheduling\n\nCrontab은 시간 기반의 스케줄링을 통해 작업을 지정된 시간에 자동으로 실행할 수 있도록 합니다.\n\n\n백업 스크립트 (Backup Scripts)BackupScripts\n\n정기적인 데이터 백업을 위해 Crontab을 사용하여 스크립트를 일정한 시간에 실행할 수 있습니다.\n\n\n로그 관리 (Log Management)LogManagement\n\n시스템 로그 파일을 관리하기 위해 Crontab을 사용하여 정기적으로 로그 파일을 회전하거나 삭제할 수 있습니다.\n\n\n시스템 유지 관리 (System Maintenance)SystemMaintenance\n\nCrontab을 통해 시스템 업데이트, 파일 정리 등 주기적인 유지 관리 작업을 자동으로 수행할 수 있습니다.\n\n\n"}}