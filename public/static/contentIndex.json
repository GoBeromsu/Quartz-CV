{"10.-Fleeting-Notes/Concurrency-Vs-Parallelism":{"title":"Concurrency Vs Parallelism","links":[],"tags":["public"],"content":"동시성 (Concurrency)\n동시성은 JavaScript에서 비동기 프로그래밍을≤ 통해 구현됩니다. 단일 스레드 언어인 JavaScript는 이벤트 루프를 사용하여 여러 작업을 효율적으로 처리할 수 있습니다.\n이벤트 루프\n\n이벤트 루프(Event Loop) 는 프로그램 주위를 도는 큰 루프로 생각할 수 있습니다. 처리할 일이 없을 때는 멈춰있다가, 이벤트가 발생하면 해당 이벤트를 큐에 추가하고 하나씩 코드를 실행합니다.\n\n예를 들어:\nconsole.log(&quot;시작&quot;);\n \nsetTimeout(() =&gt; console.log(&quot;타이머 1&quot;), 0);\nsetTimeout(() =&gt; console.log(&quot;타이머 2&quot;), 0);\n \nPromise.resolve().then(() =&gt; console.log(&quot;프로미스 1&quot;));\nPromise.resolve().then(() =&gt; console.log(&quot;프로미스 2&quot;));\n \nconsole.log(&quot;끝&quot;);\n실행 결과:\n시작\n끝\n프로미스 1\n프로미스 2\n타이머 1\n타이머 2\n\n이 예제는 동기 코드, 마이크로태스크(Promise), 매크로태스크(setTimeout)의 실행 순서를 보여줍니다.\n비동기 함수\nES6부터 도입된 async/await 문법을 사용하면 비동기 코드를 마치 동기 코드처럼 작성할 수 있습니다. 이는 코드를 더 읽기 쉽게 만들어 줍니다.\n예를 들어:\nasync function fetchUserData(userId) {\n  try {\n    const response = await fetch(`api.example.com/users/${userId}`);\n    const userData = await response.json();\n    console.log(userData);\n  } catch (error) {\n    console.error(&quot;사용자 데이터를 가져오는 데 실패했습니다:&quot;, error);\n  }\n}\n \nfetchUserData(123);\n이 함수는 사용자 데이터를 비동기적으로 가져오면서도, 동기 코드처럼 읽히도록 작성되었습니다.\n\n병렬성 (Parallelism)\nJavaScript는 기본적으로 단일 스레드에서 실행되지만, Web Workers를 사용하면 일부 병렬 처리가 가능합니다.\nWeb Workers\n\nWeb Worker는 메인 스크립트와 함께 실행되는 별도의 JavaScript 프로세스로, 자체적인 실행 흐름을 가집니다.\n복잡하고 시간이 오래 걸리는 작업을 백그라운드에서 실행하여 메인 스레드의 응답성을 유지할 수 있습니다.\n\n예를 들어:\nmain.js\nconst worker = new Worker(&#039;worker.js&#039;);\n \nworker.onmessage = function(event) {\n  console.log(&#039;워커로부터 받은 결과:&#039;, event.data);\n};\n \nworker.postMessage([1, 2, 3, 4, 5]);\nworker.js\nself.onmessage = function(event) {\n  const numbers = event.data;\n  const result = numbers.reduce((sum, num) =&gt; sum + num, 0);\n  self.postMessage(result);\n};\n이 예제에서 워커는 메인 스크립트와 병렬로 실행되어 배열의 합계를 계산합니다.\n\n정리\n\n\n동시성 (Concurrency)\n\nJavaScript의 이벤트 루프를 통해 구현\n비동기 프로그래밍(콜백, Promise, async/await)을 사용\n단일 스레드에서 여러 작업을 효율적으로 관리\n\n\n\n병렬성 (Parallelism)\n\nWeb Workers를 통해 제한적으로 구현 가능\n메인 스레드와 별도로 백그라운드에서 스크립트 실행\nCPU 집약적인 작업에 유용\n\n\n\nJavaScript에서는 주로 동시성을 활용하여 비동기 작업을 처리하며, 필요한 경우 Web Workers를 통해 병렬 처리를 수행합니다. 이를 통해 효율적이고 반응성 높은 웹 애플리케이션을 구축할 수 있습니다."},"10.-Fleeting-Notes/그라운드-루프(Ground-Loop)":{"title":"그라운드 루프(Ground Loop)","links":["험-(Hum)","tags/AudioNoise","갈바닉-절연-(Galvanic-Isolation)","tags/ElectricalEngineering","디퍼렌셜-시그널링-(Differential-Signaling)","tags/SignalProcessing","접지-(Grounding)","tags/ElectricalSafety"],"tags":["AudioEngineering","ElectricalEngineering","SoundQuality","NoiseReduction","SignalProcessing","terminology","GroundLoop","AudioNoise","public","ElectricalSafety"],"content":"그라운드 루프 (Ground Loop)\nWhat is Ground Loop\n\n\n정의 (Definition):\n\n그라운드 루프는 오디오 시스템에서 발생하는 전기적 간섭 현상으로, 두 개 이상의 장치가 서로 다른 접지점을 통해 연결될 때 발생합니다(Ballou, 2015).\n이는 시스템 내에서 원치 않는 전류가 흐르게 되어 오디오 신호에 노이즈나 험(hum)을 유발합니다(White &amp; Louie, 2005).\n그라운드 루프는 일반적으로 60Hz(미국) 또는 50Hz(유럽, 아시아 등) 주파수의 험으로 나타납니다(Huber &amp; Runstein, 2013).\n\n\n\n예시 (Examples):\n\n믹싱 콘솔과 파워 앰프가 서로 다른 전원 콘센트에 연결되어 있을 때 그라운드 루프가 발생할 수 있습니다.\n컴퓨터의 오디오 인터페이스와 외부 프리앰프 사이에 그라운드 루프가 형성되어 녹음 시 험이 들리는 경우.\n비디오 프로젝터와 오디오 시스템이 연결된 홈 시어터 설치에서 화면에 노이즈 라인이 보이고 스피커에서 험이 들리는 현상.\n\n\n\n그라운드 루프의 발생 원인\n\n다중 접지 지점: 여러 장치가 서로 다른 접지 지점을 사용하여 연결될 때, 접지 간 전위 차이로 인해 그라운드 루프가 형성될 수 있습니다.\n비균형 전원 공급: 전력 공급 장치가 완전히 접지되지 않았거나, 접지 임피던스가 높을 경우 전위 차이가 발생할 수 있습니다.\n케이블 배치: 오디오 케이블이 전원 케이블과 가까이 배치되거나, 장비 간 케이블 길이가 상이할 경우 간섭이 증가할 수 있습니다.\n전자기 간섭 (EMI): 외부 전자기장이 시스템 내의 접지 루프에 영향을 미쳐 노이즈를 유발할 수 있습니다.\n\n그라운드 루프의 영향\n\n오디오 품질 저하: 험 소리, 윙윙거리는 소리, 또는 기타 잡음이 오디오 신호에 섞여 음질을 저하시킵니다.\n장비 손상: 지속적인 불필요한 전류 흐름은 오디오 장비의 성능 저하 또는 손상을 초래할 수 있습니다.\n신호 왜곡: 신호 경로에 간섭이 발생하여 원래의 오디오 신호가 왜곡될 수 있습니다.\n\n그라운드 루프의 진단 방법\n\n험 소리 확인: 오디오 시스템에서 지속적인 험 소리가 발생하는지 확인합니다.\n장비 분리 테스트: 모든 장비를 하나씩 분리하여 험 소리가 사라지는 장비를 찾습니다.\n접지 점 점검: 시스템 내의 모든 접지 지점을 점검하고, 접지 연결이 올바르게 이루어져 있는지 확인합니다.\n케이블 검토: 오디오 케이블이 전원 케이블과 물리적으로 간섭되지 않도록 재배치합니다.\n\n그라운드 루프 해결 방안\n\n갈바닉 절연 (Galvanic Isolation):\n\n갈바닉 절연 장치를 사용하여 두 회로 간의 전기적 연결을 차단함으로써 그라운드 루프를 방지합니다. 이는 트랜스포머 기반 아이솔레이터나 광학 아이솔레이터를 통해 구현할 수 있습니다.\n\n\n균형 잡힌 오디오 연결 (Balanced Audio Connections):\n\nXLR 케이블과 같은 균형 잡힌 케이블을 사용하여 노이즈를 상쇄시키고, 신호의 무결성을 유지합니다\n\n\n단일 접지 점 사용 (Single Ground Point):\n\n시스템 내의 모든 장비를 단일 접지 지점으로 연결하여 전위 차이를 최소화합니다.\n\n\n접지 루프 브레이커 (Ground Loop Breakers):\n\n접지 루프 브레이커를 설치하여 불필요한 전류 흐름을 차단하고, 험 소리를 제거합니다.\n\n\n전원 필터링 및 차단:\n\n전원 공급 장치에 필터를 추가하거나, 노이즈를 차단하는 차단기를 사용하여 간섭을 줄입니다.\n\n\n\nLiterature Review\nBallou, 2015\n\nHandbook for Sound Engineers\n\nSource: Routledge\n\n\n주요 내용 (Key points):\n\n그라운드 루프의 원인과 메커니즘에 대한 상세한 설명을 제공합니다.\n다양한 오디오 시스템에서 그라운드 루프를 식별하고 해결하는 방법을 논의합니다.\n그라운드 루프 방지를 위한 시스템 설계 및 설치 가이드라인을 제시합니다.\n\n\n\nHuber &amp; Runstein, 2013\n\nModern Recording Techniques\n\nSource: Focal Press\n\n\n주요 내용 (Key points):\n\n레코딩 스튜디오 환경에서 발생하는 그라운드 루프 문제를 다룹니다.\n그라운드 루프로 인한 노이즈를 제거하기 위한 실용적인 기술과 도구를 소개합니다.\n균형 잡힌(balanced) 오디오 연결의 중요성과 그라운드 루프 방지에 미치는 영향을 설명합니다.\n\n\n\n관련 개념 (Related Concepts)\n\n험 (Hum)AudioNoise\n\n그라운드 루프로 인해 발생하는 가장 일반적인 형태의 오디오 노이즈로, 주로 전원 주파수(50/60Hz)와 관련이 있습니다.\n\n\n갈바닉 절연 (Galvanic Isolation)ElectricalEngineering\n\n두 회로 사이의 전기적 연결을 차단하여 그라운드 루프를 방지하는 기술입니다.\n\n\n디퍼렌셜 시그널링 (Differential Signaling)SignalProcessing\n\n균형 잡힌(balanced) 오디오 연결에서 사용되는 기술로, 그라운드 루프로 인한 노이즈를 상쇄시키는 데 도움이 됩니다.\n\n\n접지 (Grounding)ElectricalSafety\n\n올바른 접지 기술은 그라운드 루프 형성을 방지하고 전기 안전을 보장하는 데 중요합니다.\n\n\n"},"20.-Permanent-Notes/What-is-Normalization":{"title":"What is Normalization","links":["Machine-Learning","Data-Analysis","k-nearest-neighbors","Gradient-Descent"],"tags":["public"],"content":"Data Normalization\nData normalization is a crucial preprocessing step in Machine Learning and Data Analysis. It involves adjusting the scales of features so that they contribute equally to the model’s learning process. Without normalization, features with larger magnitudes can disproportionately influence the model, leading to biased results.\nWhy is Normalization Necessary?\nWhen datasets contain features with varying scales, models can become biased toward features with larger values. This imbalance can negatively impact the performance of algorithms that rely on distance calculations, such as k-nearest neighborsor Gradient Descent optimization in neural networks.\nExample: Classifying Malnourished Children\nConsider a dataset where we aim to classify whether a child is malnourished based on their weight and age:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeight (kg)Age (years)Malnourished?9.11.1No9.01.1No5.00.5Yes8.01.5No6.10.9Yes9.21.5No18.31.9No\n\nThe Problem: The weight values are significantly larger than the age values. Algorithms that compute distances may focus mainly on weight, ignoring age.\nThe Solution: Normalize the data so that weight and age contribute equally to the distance calculations.\n\nData Normalization Strategies\nNormalization techniques adjust the data to a common scale, ensuring that each feature contributes proportionately to the final result. Below are common normalization methods:\n1. Min-Max Scaling\nMin-max scaling rescales the data to a fixed range, typically [0, 1] or [-1, 1].\nFormula:\nX_{\\text{norm}} = \\frac{X - X_{\\min}}{X_{\\max} - X_{\\min}}\nCharacteristics:\n\nAdvantages: Preserves the relationships among the original data values.\nDisadvantages: Sensitive to outliers, which can skew the scaling.\n\n2. Z-Score Normalization (Standardization)\nThis method transforms the data so that it has a mean of 0 and a standard deviation of 1.\nFormula:\nX_{\\text{std}} = \\frac{X - \\mu}{\\sigma}\n\n( \\mu ) is the mean of the feature.\n( \\sigma ) is the standard deviation.\n\nCharacteristics:\n\nAdvantages: Handles outliers better than min-max scaling.\nDisadvantages: Assumes the data is normally distributed.\n\n3. Robust Scaling\nRobust scaling uses the median and interquartile range, making it robust to outliers.\nFormula:\nX_{\\text{scaled}} = \\frac{X - \\text{Median}}{\\text{IQR}}\n\nIQR is the Interquartile Range (Q3 - Q1).\n\nCharacteristics:\n\nAdvantages: Minimizes the influence of outliers.\nDisadvantages: May not normalize the data to a specific range.\n\n4. Log Transformation\nApplies a logarithmic function to reduce skewness and handle exponential relationships.\nFormula:\n\nX_{\\text{log}} = \\log(X + 1)\nCharacteristics:\n\nAdvantages: Useful for positively skewed distributions.\nDisadvantages: Only applicable to positive values.\n\n5. Decimal Scaling\nScales the data by moving the decimal point of values.\nFormula:\nX_{\\text{scaled}} = \\frac{X}{10^j}\n\n\nj is the smallest integer such that \\max(|X_{\\text{scaled}}|) &lt; 1\n\nCharacteristics:\n\nAdvantages: Simple to implement.\nDisadvantages: Less common and may not handle all scaling needs.\n\nSummary\nNormalization is essential for:\n\nReducing Bias: Ensures that no single feature dominates due to scale.\nImproving Convergence: Helps optimization algorithms converge faster.\nEnhancing Performance: Leads to better model accuracy and reliability.\n\nBy selecting an appropriate normalization strategy, we can preprocess our data to improve model performance and achieve more accurate results."},"Obsidian/Metadata-auto-classifer를-만들게-된-이유":{"title":"Metadata-auto classifer를 만들게 된 이유","links":["🔥-Programmer"],"tags":["Technology","SoftwareDevelopment","ArtificialIntelligence","public"],"content":"Obsidian 플러그인 ‘Metadata Auto Classifier’를 개발한 이유\n최근에 저는 Obsidian 플러그인인 Metadata-Auto-Classifier를 개발하고 있습니다. 가장 큰 동기는 제가 가장 좋아하는 도구인 Obsidian에서 직접 플러그인을 만들어보고 싶었기 때문입니다. 또한, 이름에서 알 수 있다시피 직접 노트에 메타데이터를 입력하는 것이 번거로워서 이를 해결하고 싶었습니다.\n메타 데이터는 왜 중요할까?\nObsidian은 Notion이나 다른 데이터베이스처럼 노트에 메타데이터를 추가할 수 있습니다. 처음에는 태그나 별칭(alias) 외에 커스텀 메타데이터를 추가하는 것의 중요성을 잘 몰랐습니다. 그러나 노트가 점점 많아지면서 메타데이터의 가치가 얼마나 큰지 깨닫게 되었습니다.\n노트의 내용이 길어지고 수가 많아질수록, 다시 그 노트로 돌아왔을 때 맥락을 이해하는 데 시간이 더 걸립니다. 이때 메타데이터는 그 노트가 어떤 주제인지, 어떤 목적을 가지고 있는지를 빠르게 알려줍니다. 생성 날짜, 제목, 태그 등의 메타데이터를 통해 노트의 특성을 파악하고 관련된 내용을 연상할 수 있습니다.\n잘 작성된 메타데이터는 해당 노트가 내 지식 체계에서 어떤 위치를 차지하는지 알려주어 정보 관리에 큰 도움이 됩니다. 예를 들어, JavaScript 튜토리얼을 작성하고 싶다면 다음과 같이 메타데이터를 활용할 수 있습니다:\n\n프로젝트 노트 검색: JavaScript로 만든 프로젝트 노트를 찾아볼 수 있습니다.\n태그 활용: ‘js’ 태그가 붙은 노트를 모아볼 수 있습니다.\n역할 기반 필터링: ‘개발자’라는 메타데이터가 있는 노트를 찾아 내가 개발자로서 JavaScript를 어떻게 사용했는지 확인할 수 있습니다.\n주제별 페이지 탐색: ‘JavaScript’라는 이름의 페이지를 찾아 관련 정보를 종합할 수 있습니다.\n\n이처럼 메타데이터를 활용하면 여러 관점에서 JavaScript에 대한 정보를 체계적으로 모을 수 있습니다.\n메타데이터를 통한 지식 강화\n\n자유도가 높은 Obsidian 환경에서 프론트 매터(메타데이터)는 우리의 지식을 바라보는 데 추가적인 차원을 제공합니다. 특정 메타데이터를 기반으로 노트를 모아서—프로젝트 노트나 개발자 인사이트처럼—작업의 특정 측면에 집중할 수 있습니다. 이러한 조직화는 제가 개발자로서 수행한 모든 작업을 보거나 특정 프로젝트와 관련된 모든 노트를 검토할 수 있게 해줍니다.\n실제 제 노트를 예시로 들면 제가 프로그래밍 관련 기록을 할 때는 persona라는 속성에 🔥 Programmer 노트를 링크를 해둡니다.\n\n위와 같이 링크가 쌓이면, 나중에 🔥 Programmer노트를 찾아 갔을 때는 아래와 같이 제가 프로그래밍 관련 일을 얼마나 했는지 알 수 있습니다!\n\n결과적으로 메타데이터는 방대한 노트들 사이에서 필요한 정보를 빠르게 찾고, 지식을 효율적으로 관리하는 데 필수적인 역할을 합니다.\n플러그인 소개\nMetadata-Auto-Classifier은 현재 노트의 내용을 분석하여 LLM를 사용해 각 메타데이터 필드에 대한 값을 추천합니다. 문서의 내용을 읽고, 해당 노트의 여러 프론트매터를 순차적으로 입력할 수 있습니다. 사용자는 자신이 설정한 속성에 따라 노트를 분류할 수 있습니다. 이를 위해 기본 값으로 tags를 설정해두었으며, 현재 가지고 있는 모든 태그 중 연관성에 따라 자동으로 태그를 삽입할 수 있습니다.\n따라서, 프론트매터 입력 및 사용자 조정이 가능하며, 입력 항목의 개수도 조절이 가능합니다\n현재 지원 기능\n\n\n\nAPI를 통한 자동 문서 분류\n\nAI 모델을 사용하여 문서 내용을 분석하고 적절한 카테고리를 자동으로 할당합니다.\n\n\n\n사용자 정의 프론트매터 생성\n\n사용자가 원하는 대로 프론트매터 필드를 추가하고 관리할 수 있습니다.\n\n\n\n태그 자동 생성\n\n문서 내용을 기반으로 관련 태그를 자동으로 생성합니다.\n\n\n\n개발자로서 고민하고 있는 포인트\n1. 오픈 소스 AI 모델 지원 확대\n\n다양한 LLM 통합: 현재는 OpenAI API를 사용하고 있지만, 플러그인의 유연성과 접근성을 높이기 위해 로컬 LLM(Local Language Model)이나 다른 오픈 소스 AI 모델과의 호환성을 고려하고 있습니다. 이를 통해 사용자는 자신이 선호하는 AI 모델을 선택하거나 커스텀 모델을 적용할 수 있게 됩니다.\n모듈식 아키텍처 설계: 다양한 AI 모델을 지원하기 위해 플러그인의 아키텍처를 모듈화하고자 합니다. 인터페이스나 추상 클래스를 정의하여 각 AI 제공자별로 구현체를 만들 수 있도록 구조를 설계하면, 새로운 모델 추가 시 코드 변경을 최소화할 수 있습니다.\n성능 및 호환성 검증: 오픈 소스 모델은 성능이나 API 구조가 다양하므로, 각 모델에 대한 성능 테스트와 호환성 검증이 필요합니다.\n\n이를 위해 자동화된 테스트 스위트를 구축하고, 지속적인 통합(CI) 환경에서 검증 과정을 통합할 계획입니다.\nObsidian에서 테스트 케이스를 어떻게 만들까 고민입니다 하하\n\n\n\n2. 부분적 컨텍스트 분석 지원\n\n선택 영역 기반 처리: 사용자가 노트의 특정 부분을 선택하면 해당 부분만을 기반으로 메타데이터를 생성할 수 있도록 기능을 추가하고자 합니다. 이를 위해 에디터에서 선택된 텍스트를 감지하고, 그 내용을 AI 모델에 전달하는 로직을 구현해야 합니다.\n콘텐츠 분할 및 병렬 처리: 긴 노트의 경우 토큰 제한에 걸릴 수 있으므로, 노트를 의미 있는 단위로 분할하여 각 부분을 개별적으로 처리한 후 결과를 통합하는 방법을 고려하고 있습니다.\n맥락 유지 전략: 부분적인 내용만으로 메타데이터를 생성할 때 전체 문맥이 손실될 수 있으므로, 노트의 요약 정보나 주요 키워드를 함께 제공하여 AI 모델이 보다 정확한 결과를 도출할 수 있도록 할 계획입니다.\n\n3. 사용자 정의 분류 기준 제공\n각 프론트매터 항목이 어떻게 구분되어야 하는지에 대한 명확한 지침이나 예시를 사용자로부터 입력받아 AI 모델에 전달함으로써 분류 정확도를 높이고자 합니다. 현재는 분류해야 할 값을 유저가 넣어주면 AI가 판단하고 넘기도록 하고 있습니다. 분류 항목에 대한 맥락을 추가하면 좀 더 사용자가 의도한 대로 분류를 할 수 있을 것이라 생각합니다.\n4. 대용량 노트 처리 전략\n\n토큰 제한 대응 방안: 현재는 노트 전체를 한 번에 처리하지만, 긴 노트의 경우 토큰 제한으로 인해 문제가 발생할 수 있습니다. 이를 해결하기 위해 노트를 일정한 크기로 분할하고, 각 부분을 순차적으로 또는 병렬로 처리한 후 결과를 종합하는 방법을 고려하고 있습니다.\n요약 기반 처리: 노트의 핵심 내용을 추출하거나 요약본을 생성하여, 그 요약된 정보를 기반으로 메타데이터를 생성하는 방법도 검토하고 있습니다. 이를 통해 처리 시간을 단축하고 토큰 제한 문제를 완화할 수 있습니다.\n메모리 및 성능 최적화: 대용량 데이터를 처리할 때 메모리 사용량을 최소화하고 성능을 최적화하기 위한 알고리즘과 데이터 구조를 적용할 계획입니다.\n\n5. 향상된 사용자 경험 (UX) 개선\n\n직관적인 UI 디자인: 플러그인의 인터페이스를 개선하여 사용자가 기능을 쉽게 이해하고 활용할 수 있도록 노력하고 있습니다. 아이콘, 메뉴 구조, 설정 화면 등을 재설계하여 사용자 친화성을 높이고자 합니다.\n실시간 피드백 제공: 메타데이터 생성 과정에서 진행 상태나 결과를 실시간으로 표시하여 사용자에게 투명성을 제공합니다. 예를 들어, 진행률 표시바나 알림 메시지를 통해 사용자가 현재 어떤 작업이 진행 중인지 알 수 있도록 합니다.\n사용자 맞춤 설정 강화: 다양한 사용자 요구에 대응하기 위해 설정 옵션을 확대하고, 프리셋이나 프로파일 기능을 도입하여 사용자가 자신의 작업 흐름에 맞게 플러그인을 커스터마이즈할 수 있도록 할 계획입니다.\n도움말 및 가이드 제공: 플러그인의 기능과 사용 방법을 쉽게 이해할 수 있도록 튜토리얼, FAQ, 툴팁 등의 도움말을 제공하고자 합니다. 이를 통해 초기 사용자도 부담 없이 플러그인을 활용할 수 있습니다.\n에러 처리 및 로그 기능 개선: 오류 발생 시 명확한 에러 메시지와 해결 방법을 제시하고, 로그 기능을 통해 문제 진단이 용이하도록 시스템을 개선할 예정입니다.\n"},"index":{"title":"Home","links":[],"tags":["public"],"content":"\n설렘으로 선을 이루자, 그렇게 탁월해지자\n\n\nCurrently a Developer &amp; Postgraduate\n🌟 Striving to make the world a better place\n🚀 Interested in Productivity, LLM, Obsidian\n"}}