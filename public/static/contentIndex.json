{"Concurrency-Vs-Parallelism":{"title":"Concurrency Vs Parallelism","links":[],"tags":[],"content":"동시성 (Concurrency)\n동시성은 JavaScript에서 비동기 프로그래밍을≤ 통해 구현됩니다. 단일 스레드 언어인 JavaScript는 이벤트 루프를 사용하여 여러 작업을 효율적으로 처리할 수 있습니다.\n이벤트 루프\n\n이벤트 루프(Event Loop) 는 프로그램 주위를 도는 큰 루프로 생각할 수 있습니다. 처리할 일이 없을 때는 멈춰있다가, 이벤트가 발생하면 해당 이벤트를 큐에 추가하고 하나씩 코드를 실행합니다.\n\n예를 들어:\nconsole.log(&quot;시작&quot;);\n \nsetTimeout(() =&gt; console.log(&quot;타이머 1&quot;), 0);\nsetTimeout(() =&gt; console.log(&quot;타이머 2&quot;), 0);\n \nPromise.resolve().then(() =&gt; console.log(&quot;프로미스 1&quot;));\nPromise.resolve().then(() =&gt; console.log(&quot;프로미스 2&quot;));\n \nconsole.log(&quot;끝&quot;);\n실행 결과:\n시작\n끝\n프로미스 1\n프로미스 2\n타이머 1\n타이머 2\n\n이 예제는 동기 코드, 마이크로태스크(Promise), 매크로태스크(setTimeout)의 실행 순서를 보여줍니다.\n비동기 함수\nES6부터 도입된 async/await 문법을 사용하면 비동기 코드를 마치 동기 코드처럼 작성할 수 있습니다. 이는 코드를 더 읽기 쉽게 만들어 줍니다.\n예를 들어:\nasync function fetchUserData(userId) {\n  try {\n    const response = await fetch(`api.example.com/users/${userId}`);\n    const userData = await response.json();\n    console.log(userData);\n  } catch (error) {\n    console.error(&quot;사용자 데이터를 가져오는 데 실패했습니다:&quot;, error);\n  }\n}\n \nfetchUserData(123);\n이 함수는 사용자 데이터를 비동기적으로 가져오면서도, 동기 코드처럼 읽히도록 작성되었습니다.\n\n병렬성 (Parallelism)\nJavaScript는 기본적으로 단일 스레드에서 실행되지만, Web Workers를 사용하면 일부 병렬 처리가 가능합니다.\nWeb Workers\n\nWeb Worker는 메인 스크립트와 함께 실행되는 별도의 JavaScript 프로세스로, 자체적인 실행 흐름을 가집니다.\n복잡하고 시간이 오래 걸리는 작업을 백그라운드에서 실행하여 메인 스레드의 응답성을 유지할 수 있습니다.\n\n예를 들어:\nmain.js\nconst worker = new Worker(&#039;worker.js&#039;);\n \nworker.onmessage = function(event) {\n  console.log(&#039;워커로부터 받은 결과:&#039;, event.data);\n};\n \nworker.postMessage([1, 2, 3, 4, 5]);\nworker.js\nself.onmessage = function(event) {\n  const numbers = event.data;\n  const result = numbers.reduce((sum, num) =&gt; sum + num, 0);\n  self.postMessage(result);\n};\n이 예제에서 워커는 메인 스크립트와 병렬로 실행되어 배열의 합계를 계산합니다.\n\n정리\n\n\n동시성 (Concurrency)\n\nJavaScript의 이벤트 루프를 통해 구현\n비동기 프로그래밍(콜백, Promise, async/await)을 사용\n단일 스레드에서 여러 작업을 효율적으로 관리\n\n\n\n병렬성 (Parallelism)\n\nWeb Workers를 통해 제한적으로 구현 가능\n메인 스레드와 별도로 백그라운드에서 스크립트 실행\nCPU 집약적인 작업에 유용\n\n\n\nJavaScript에서는 주로 동시성을 활용하여 비동기 작업을 처리하며, 필요한 경우 Web Workers를 통해 병렬 처리를 수행합니다. 이를 통해 효율적이고 반응성 높은 웹 애플리케이션을 구축할 수 있습니다."},"Error-Handling-in-GitHub-Workflow-Extensions":{"title":"Error Handling in GitHub Workflow Extensions","links":[],"tags":["PluginExtension","ProgrammingTools","ErrorHandling","GitHubWorkflow","SoftwareDevelopment","post/medium","Git","Obsidian"],"content":"I recently created my first community plugin for Obsidian, which has basic functions for practicing pronunciation. After submitting it, I received feedback from a reviewer suggesting I change the plugin’s name because its features are more focused on the pronunciation of selected text.\nFollowing the advice, I updated the information in manifest.json, README, and the repository name. After making these changes, I submitted my pull request (PR) again but encountered an error:\nError: fatal: couldn&#039;t find remote ref refs/pull/4172/merge\nThe process &#039;/usr/bin/git&#039; failed with exit code 128\n\nI believe the error was caused by the repository name change. Even though I updated everything, the workflow still referenced the same old information:\nRepo info: goberomsu/british-pronunciation-plugin\nFound issue: Your repository does not have issues enabled. Users will not be able to report bugs and request features.\n\nFortunately, I realized what was wrong and fixed it!\nHow to Solve This Issue\nIf you’re facing a similar issue, as discussed in this forum post, here’s a simple solution:\n\nDelete the Obsidian release fork: Remove the forked repository from your GitHub account.\nFork the release again: Fork the original repository once more to your account.\nCreate a new Pull Request (PR): After making your changes, open a new PR to submit your code.\n\nThis process resets the fork, allowing you to avoid the “couldn’t find remote ref” error during validation."},"Javascript-Asynchronous-Programming":{"title":"Javascript Asynchronous Programming","links":["Strack-자료구조","Concurrency-Vs-Parallelism"],"tags":["AsynchronousProgramming","JavaScriptConcepts","EventLoop"],"content":"Asynchronous programming in JavaScript is a technique that allows the program to start potentially time-consuming tasks and continue executing other tasks without waiting for the initial task to complete.\nThis approach is essential in web development where operations like fetching data from a server, reading files, or executing time-consuming computations can block the main thread, leading to unresponsive interfaces.\nKey Concepts in Asynchronous Programming\nCallbacks\nFunctions passed as arguments to other functions to be executed after the first function has completed. For example:\nsetTimeout(() =&gt; console.log(&quot;Tick&quot;), 500);\nPromises\nObjects representing the eventual completion or failure of an asynchronous operation. They can be chained and managed more systematically than callbacks.\nlet fifteen = Promise.resolve(15);\nfifteen.then(value =&gt; console.log(`Got ${value}`));\nAsync/Await\nSyntactic sugar built on top of promises, making asynchronous code easier to write and read by allowing asynchronous code to be structured similarly to synchronous code.\nasync function example() {\n  let result = await someAsyncOperation();\n  console.log(result);\n}\nThe Event Loop\nJavaScript uses an event loop to handle asynchronous operations:\n\nThe main script runs first, often setting up callbacks for later execution.\nWhen the main script completes, the program may become idle, waiting for events.\nAs events occur (e.g., timeouts, network responses), their associated callbacks are added to a queue.\nThe event loop processes these queued callbacks one by one.\n\nThis model ensures that JavaScript remains single-threaded, executing only one piece of code at a time.\nTo better understand how JavaScript handles asynchronous operations, it’s crucial to grasp the concept of the event loop and the order in which callbacks are executed. Let’s break it down:\n\n\nThe Call Stack:\n\nJavaScript uses a call stack to keep track of where it is in the program.\nWhen a function is called, it’s added to the stack. When it returns, it’s removed from the stack.\n\n\n\nThe Event Loop:\n\nThe event loop continuously checks if the call stack is empty.\nIf it’s empty, it looks at the callback queue to see if there are any functions waiting to be executed.\n\n\n\nCallback Queue:\n\nThere are actually two types of queues: the microtask queue and the macrotask queue.\nMicrotasks (like Promise callbacks) have priority over macrotasks (like setTimeout callbacks).\n\n\n\nLet’s look at an example:\nconsole.log(&#039;Start&#039;);\n \nsetTimeout(() =&gt; {\n  console.log(&#039;Timeout (Macrotask)&#039;);\n}, 0);\n \nPromise.resolve().then(() =&gt; {\n  console.log(&#039;Promise (Microtask)&#039;);\n});\n \nconsole.log(&#039;End&#039;);\nStart\nEnd\nPromise (Microtask)\nTimeout (Macrotask)\n\n\nconsole.log(&#039;Start&#039;) is executed immediately.\nsetTimeout is encountered. Its callback is scheduled as a macrotask.\nThe Promise’s then callback is scheduled as a microtask.\nconsole.log(&#039;End&#039;) is executed immediately.\nThe call stack is now empty, so the event loop checks the microtask queue first.\nThe Promise callback (microtask) is executed, logging ‘Promise (Microtask)‘.\nThe microtask queue is now empty, so the event loop moves to the macrotask queue.\nThe setTimeout callback (macrotask) is executed, logging ‘Timeout (Macrotask)‘.\n\nKey Takeaways for Junior Developers\n\nSingle-Threaded Nature: JavaScript is single-threaded, meaning it can only do one thing at a time.\nAsynchronous Operations: Functions like setTimeout and Promises allow JavaScript to perform non-blocking operations.\nMicrotasks vs Macrotasks:\n\nMicrotasks (Promises, queueMicrotask) are processed before macrotasks (setTimeout, setInterval, I/O operations).\nThis prioritization ensures that Promise resolutions are handled as soon as possible.\n\n\nEvent Loop: It’s the mechanism that allows JavaScript to perform non-blocking operations despite being single-threaded.\n\nAsynchronous Patterns\nPromise Chaining\nPromises can be chained to handle sequences of asynchronous operations:\nfetchData()\n  .then(processData)\n  .then(saveResult)\n  .catch(handleError);\nParallel Execution\nPromise.all allows multiple asynchronous operations to run concurrently:\nPromise.all([fetchUser(), fetchPosts()])\n  .then(([user, posts]) =&gt; {\n    // Use user and posts data\n  });\nAsync Functions\nAsync functions provide a cleaner syntax for working with promises:\nasync function fetchUserData() {\n  try {\n    let user = await fetchUser();\n    let posts = await fetchPosts(user.id);\n    return { user, posts };\n  } catch (error) {\n    console.error(&quot;Error fetching user data:&quot;, error);\n  }\n}\nCommon Pitfalls\n\nCallback Hell: Nesting multiple callbacks can lead to unreadable and hard-to-maintain code.\nForgetting to handle errors in asynchronous code.\nMisunderstanding the asynchronous nature of operations, leading to race conditions or unexpected behavior.\n\nBest Practices\n\nUse promises or async/await instead of nested callbacks.\nAlways handle errors in asynchronous code.\nBe aware of the event loop and how it affects the execution of your code.\nUse Promise.all for concurrent operations when appropriate.\nAvoid blocking the main thread with long-running synchronous operations.\n\nTip\nConcurrency Vs Parallelism\nClarify the difference between concurrency (managing multiple tasks over the same time period) and parallelism (executing multiple tasks simultaneously).\nJavaScript is single-threaded but can handle concurrent operations through asynchronous programming, even though it doesn’t perform tasks in parallel unless using Web Workers.\nBest Practices Enhancements\nAvoiding Overuse of Async/Await\n\n\nExplanation: Not all functions need to be asynchronous. Overusing async can lead to unnecessary promise creation, which can affect performance.\n\n\nExample:\n// Unnecessary async\nasync function add(a, b) {\n  return a + b;\n}\n \n// Better\nfunction add(a, b) {\n  return a + b;\n}\n\n\nHandling Multiple Asynchronous Operations in Loops\n\n\nInefficient Approach:\nfor (const url of urls) {\n  await fetchAndProcess(url);\n}\n\n\nEfficient Approach:\nawait Promise.all(urls.map(url =&gt; fetchAndProcess(url)));\n\n\nInsight: Running asynchronous operations in parallel when possible improves performance.\n\n\nUsing Linters and Code Style Guides\n\n\nExplanation: Enforce consistent asynchronous code patterns using tools like ESLint with plugins for promises and async/await.\n\n\nExample ESLint Configuration:\n{\n  &quot;plugins&quot;: [&quot;promise&quot;],\n  &quot;rules&quot;: {\n    &quot;promise/always-return&quot;: &quot;error&quot;,\n    &quot;promise/no-return-wrap&quot;: &quot;error&quot;,\n    &quot;promise/param-names&quot;: &quot;error&quot;\n  }\n}\n\n\nHandling Await in Loops and Conditional Statements\n\nPitfall: Using await inside loops or conditionals without proper understanding can lead to sequential execution and performance issues.\n\nUse Promise.all to run tasks in parallel when order doesn’t matter. If order matters, consider refactoring the code to allow for concurrency.\nCertainly! Here’s an expanded explanation of synchronous vs asynchronous exceptions, tailored for junior developers:\nSynchronous Vs. Asynchronous Exceptions\nSynchronous Exceptions\nSynchronous exceptions occur in the normal flow of program execution. They are immediately caught by surrounding try-catch blocks.\ntry {\n  console.log(&quot;Start of try block&quot;);\n  throw new Error(&#039;Synchronous error&#039;);\n  console.log(&quot;This line will never be executed&quot;);\n} catch (error) {\n  console.error(&quot;Caught synchronous error:&quot;, error.message);\n}\nconsole.log(&quot;Program continues executing&quot;);\n \n// Output:\n// Start of try block\n// Caught synchronous error: Synchronous error\n// Program continues executing\nKey points:\n\nThe error is thrown and caught immediately.\nCode execution in the try block stops at the point where the error is thrown.\nThe catch block is executed right away.\nProgram execution continues after the try-catch block.\n\nAsynchronous Exceptions\nAsynchronous exceptions occur in code that runs at a later time, such as in Promises, setTimeout, or event callbacks. These cannot be caught by a regular try-catch block surrounding the asynchronous function call.\ntry {\n  console.log(&quot;Start of try block&quot;);\n  Promise.reject(new Error(&#039;Asynchronous error&#039;));\n  console.log(&quot;This line will be executed&quot;);\n} catch (error) {\n  console.error(&quot;This catch block will not catch the async error&quot;);\n}\n \n// Proper way to handle asynchronous errors\nPromise.reject(new Error(&#039;Asynchronous error&#039;))\n  .catch(error =&gt; {\n    console.error(&quot;Caught asynchronous error:&quot;, error.message);\n  });\n \nconsole.log(&quot;Program execution continues immediately&quot;);\n \n// Output:\n// Start of try block\n// This line will be executed\n// Program execution continues immediately\n// Caught asynchronous error: Asynchronous error\nKey points:\n\nThe Promise.reject doesn’t throw an error immediately; it schedules it for later.\nThe try-catch block surrounding the Promise creation is ineffective for catching the async error.\nAsynchronous errors must be handled using .catch() on Promises or try-catch within async functions.\nThe program continues executing immediately, not waiting for the Promise to settle.\n\nWhy This Matters\n\n\nError Propagation: Synchronous errors propagate up the call stack immediately, while asynchronous errors do not.\n\n\nDebugging: Synchronous errors provide a clear stack trace to the error’s origin. Asynchronous errors can be more challenging to trace.\n\n\nProgram Flow: Unhandled synchronous exceptions can halt program execution immediately. Unhandled asynchronous exceptions might not stop the program immediately but can lead to unexpected behavior.\n\n\nError Handling Strategies: Different strategies are needed for handling synchronous and asynchronous errors effectively.\n\n"},"Solution-for-Nginx-SSL-Certificate-Passphrase-Issue":{"title":"Solution for Nginx SSL Certificate Passphrase Issue","links":[],"tags":["post/medium"],"content":"Solution for Nginx SSL Certificate Passphrase Issue\nEnsuring the seamless operation of your Nginx server, especially in automated environments like Docker, is crucial. This guide walks you through diagnosing and resolving the issue where Nginx fails to load an SSL certificate due to an encrypted key file requiring a passphrase.\nProblem Diagnosis\nLog Analysis\nReviewing the Nginx error logs reveals the following message:\nnginx: [emerg] cannot load certificate key &quot;/etc/ssl/certs/wildcard_eduroam_kr.key&quot;: PEM_read_bio_PrivateKey() failed\n(SSL: error:1400006B:UI routines::processing error:while reading strings error:0480006D:PEM routines::problems getting password\nerror:07880109:common libcrypto routines::interrupted or cancelled error:07880109:common libcrypto routines::interrupted or\ncancelled error:04800068:PEM routines::bad password read)\nThis error indicates that the wildcard_eduroam_kr.key file is encrypted and requires a passphrase, which Nginx cannot automatically provide during startup.\nRemoving the Passphrase From the Key File\nWhy Remove the Passphrase?\nFor automated environments such as Docker, manual passphrase entry during server startup is impractical. Removing the passphrase ensures Nginx can automatically load the SSL key, facilitating seamless automated deployments and operations.\nSteps to Remove the Passphrase\n\n\nExecute OpenSSL Command\nUse the openssl rsa command to create a new key file without the passphrase:\nopenssl rsa -in wildcard_eduroam_kr.key -out wildcard_eduroam_kr.key.no_pass\n\n\nEnter Passphrase\nWhen prompted, enter the current passphrase for the key file:\nEnter pass phrase for wildcard_eduroam_kr.key:\nThis will generate a new key file without a passphrase.\n\n\nVerify the New Key File\nEnsure the new key file has been created successfully:\nls -l wildcard_eduroam_kr.key.no_pass\nAnd, replace wildcard_eduroam_kr.key!\n\n\nModifying Docker Compose Configuration\nUpdating the docker-compose.yml File\nModify your docker-compose.yml to use the new key file without a passphrase:\nnginx:\n  logging:\n    driver: &quot;json-file&quot;\n    options:\n      max-size: &quot;50m&quot;\n  environment:\n    - TZ=Asia/Seoul\n  image: nginx:latest\n  container_name: nginx\n  volumes:\n    - ./nginx/nginx.conf:/etc/nginx/nginx.conf\n    - ./nginx/certs/cert_wildcard.eduroam.kr.crt:/etc/ssl/certs/cert_wildcard.eduroam.kr.crt\n    - ./nginx/certs/wildcard_eduroam_kr.key:/etc/ssl/certs/wildcard_eduroam_kr.key\n  deploy:\n    restart_policy:\n      condition: unless-stopped\n  ports:\n    - 443:443\n  networks:\n    - public\n    - private\nRebuilding and Restarting Docker Containers\nRebuild Docker Image and Restart Containers\nReflect the changes by rebuilding the Docker image and restarting the containers:\ndocker compose down\ndocker compose build\ndocker compose up -d\nRebuilding ensures that the new, unencrypted key file is used, as the key files are typically excluded from version control for security reasons and must be explicitly included in the build process.\nVerifying the Resolution\nCheck Nginx Container Logs\nConfirm that the issue is resolved by inspecting the Nginx container logs:\ndocker-compose logs nginx\nValidate Successful Startup\nEnsure the Docker container is running correctly:\ndocker ps\n\nFinally, verify that there are no errors related to certificate loading in the logs:\ndocker logs [nginx-container-ID]\n"},"Terminology-generating-workflow-with-Obsidian-and-Generative-AI":{"title":"Terminology generating workflow with Obsidian and Generative AI","links":["Perplexity","Obsidian-Plugin---Templater","Gemini","T03---Research-Terminology","2024-08-06","@구요한"],"tags":["post/medium"],"content":"General Terminology\n\nPerplexity + Obsidian Plugin - Templater\n\nwhen we learn new fields, we need to know the terminology. There is way to make terminology easier with obsidian avoiding halluciations\nFirst, find terminology by using an AI search tool like Perplexity. Then, copy the result and paste to generative AI such as Gemini and chatGPT using template\nPerplexity gives you result based on reference and chatGPT change your appropriate template.\nResearch Terminology\n\nT03 - Research Terminology\n\nShare Obsidian &amp;&amp; AI workflow\nThis is way to make a terminology for research!\nFirst, search for the terminology using consensus gpts,an AI-powered research tool.\nThen, copy the result and paste it into a template for chatGPT\nconsensus provides you result based on academic article,helping you avoid halluciations.\nchatGPT will generate you terminology note :)\nThinking\n\n2024-08-06 21:38 Reference : @구요한\n2024-08-06 21:50 easier 잘 못스네\n"},"Zotero-7-hookmark-동작-안하는-것-해결-방법":{"title":"Zotero 7 hookmark 동작 안하는 것 해결 방법","links":["조테로-(Zotero)","Hookmark"],"tags":["zotero","post/medium"],"content":"I’m currently using Zotero for my research, Zotero is free and easy to use.\nThis week, I upgraded to Zotero 7 beta because it has a better design than the previous version. However, when I launched the new Zotero and tried to use Hookmark to connect the Obsidian vault with Zotero, Hookmark was not working.\nToday, I will share how I solved this problem\nZotxt Extension\nGo to the zotxt GitHub page. Download Zotxt suitable for your version of Zotero. Install zotxt by following the instructions on the its GitHub page.\nZotxt is a Zotero extension for supporting utilities that deal with plain text files (e.g., markdown, reStructuredText, latex, etc.) This plugin will be used for Hookmark required text to make hookmark link\nZotero-markdown-translator\nGo to the silentdot/zotero-markdown-translator GitHub page. download the Zotero translator from the repository. Then install the translator by following the instructions provided on the Github page.\nThe Zotero Markdown Translator plugin creates Markdown links when exporting. To solve my problem, I needed to change the Item Format to Markdown Item URI\n\nGo to the Export tab.\nSet the Item Format to Markdown Item URI.\nThis ensures that your exported items are in the correct format for Markdown.\n\nConclusion\n\nFinally, reboot Zotero and check if the problem is solved. If you need further information,The latest discussions around Zotero 7 beta and its compatibility with Hookmark can be found here. It includes updates on potential issues and fixes related to Hookmark."},"index":{"title":"Home","links":["아버지를-존경할-이유","Javascript-Asynchronous-Programming","음향-엔지니어가-Javascript-Concurrency-Vs-Parallelism-이해하는-방법","음향-엔지니어가-JavaScript의-실행-메커니즘-이해하는-방법"],"tags":[],"content":"\n\nSample\n\n아버지를 존경할 이유\nJavascript Asynchronous Programming\n\n음향 엔지니어가 Javascript Concurrency Vs Parallelism 이해하는 방법\n음향 엔지니어가 JavaScript의 실행 메커니즘 이해하는 방법\n\n\n\n\n\nTo do list\n\ngoogle analytics 에 추가\n\n\n\nReference\n\nMinwoo Seong | phd hci @ GIST\nWelcome to Quartz 4\n개발자 유니의 두 번째 뇌\ndoors - 서울외계인의 지식정원 - Obsidian Publish\n"},"검색-엔진-Obsidian-plugin-Omnisearch-연동하기":{"title":"검색 엔진 Obsidian plugin Omnisearch 연동하기","links":[],"tags":["Omnisearch","검색엔진","Obsidian","Browser","연결","article","post/tistory"],"content":"검색엔진 Obsidian Plugin Omnisearch 연동하기\nOmnisearch는 Obsidian의 강력한 검색 플러그인으로, 다음과 같은 특징을 가지고 있습니다:\n\n다양한 파일 형식 지원: 노트, Office 문서, PDF, 이미지 등을 빠르게 검색\n오타 저항성: 검색어의 오타에도 관련 결과를 찾아냄\n필터링 기능: 다양한 파일 형식별 필터링 가능\n키보드 중심 워크플로우: 효율적인 검색 및 탐색 지원\n외부 접근성: 로컬 HTTP 서버를 통해 Obsidian 외부에서도 쿼리 가능\n\nOmnisearch를 브라우저와 연동하면 다음과 같은 이점을 얻을 수 있습니다:\n\n통합 검색 경험: 웹 검색과 개인 노트 검색을 동시에 수행\n지식 연결: 외부 정보와 개인 지식을 쉽게 연결\n맥락 이해 향상: 검색 결과의 맥락을 더욱 풍부하게 이해\n노트 활용도 증가: 개인 노트의 활용 빈도와 가치 상승\n시간 절약: 여러 플랫폼을 오가며 검색할 필요 없이 한 곳에서 모든 정보 접근\n아이디어 발견: 웹 정보와 개인 노트를 동시에 보며 새로운 연결점 발견 가능\n\n이 가이드에서는 Omnisearch를 브라우저와 연동하는 방법을 단계별로 안내하여, 사용자가 이러한 장점들을 최대한 활용할 수 있도록 돕습니다.\nOmnisearch를 Google/Kagi에 연결하는 방법\n\n\nOmnisearch의 최신 버전을 Obsidian에 설치하고, 설정에서 HTTP 서버를 활성화합니다.\n\n\n\n브라우저에 Tampermonkey (또는 다른 userscript 관리자)를 설치합니다.\n\n\n\n브라우저의 Developer Mode를 활성화합니다. 브라우저별 확장 프로그램 페이지 링크:\n\nChrome: chrome://extensions/\nArc: arc://extensions/\n\n각 브라우저에서 “개발자 모드” 또는 “Developer Mode” 토글을 찾아 활성화합니다. Chrome과 Arc는 오른쪽 상단, Edge는 왼쪽 하단에 있습니다.\n\n\n이 작업을 통해 Tampermonkey를 통해 userScripts API를 사용할 수 있게 됩니다.\n\n\n선호하는 검색 엔진에 해당하는 userscript를 설치합니다, extension을 설치하고 아래 링크에 접속하면 Tampermonkey가 접근 가능하도록 할 것이냐 물어봅니다\n\nKagi\nGoogle\nDuckDuckGo\nBing\n\n\n다음은 experimental Javascript feature를 실행시켜야 합니다\n\n\nExperimental JavaScript features를 활성화합니다. 브라우저별 설정 페이지 링크:\n\nChrome: chrome://flags/#enable-experimental-web-platform-features\nArc: arc://flags/#enable-experimental-web-platform-features\n\n각 브라우저에서 “Experimental Web Platform features”를 찾아 “Enabled”로 설정합니다.\n\n\n\n\n이제 처음 구글 search를 하면, 아래와 같이 권한을 요구합니다. 여기서 Allow를 누르시면 사용하실 수 있습니다\n\n궁금증\n왜 Developer Mode를 활성화해야 하나요?\nDeveloper Mode는 userscript의 두 단계 사용자 권한 부여를 위해 필요합니다: userScripts 권한과 Developer Mode 옵션입니다. userScripts 권한만으로는 설치 시 사용자 경고를 트리거하지 않습니다. 따라서 이 추가 단계는 사용자가 Userscripts를 사용하는 확장 프로그램을 실행하는 데 있어 신중한 결정을 내리도록 하기 위한 Google의 의도를 반영합니다.\nOmnisearch와 브라우저 연동의 동작 원리\n\n로컬 HTTP 서버: Omnisearch 플러그인은 Obsidian 내에서 로컬 HTTP 서버를 실행합니다. 이 서버는 외부 애플리케이션(이 경우 브라우저)에서 Obsidian 노트를 검색할 있게 해줍니다.\nUserscript: Tampermonkey를 통해 설치된 userscript는 브라우저의 검색 결과 페이지에 삽입됩니다. 이 스크립트는 사용자의 검색 쿼리를 감지합니다.\nAPI 요청: userscript는 감지한 검색 쿼리를 사용하여 Omnisearch의 로컬 HTTP 서버에 API 요청을 보냅니다.\n결과 처리: Omnisearch 서버는 요청을 처리하고, Obsidian 노트에서 관련된 결과를 찾아 반환합니다.\n결과 표시: userscript는 받은 결과를 처리하여 브라우저의 검색 결과 페이지에 Obsidian 노트의 검색 결과를 삽입합니다.\n"},"아버지를-존경할-이유":{"title":"아버지를 존경할 이유","links":[],"tags":["Family","Ethics","Business"],"content":"아빠한테 전화해서 존경한다고 말씀드렸다\n아버지라 부르지는 않지만, 호칭에 상관 없이 암튼 존경한다\n왜냐면, 아버지이기 때문이다, 그 무거운 이름을 짊어진 것이 정말 멋진 것임을 점점 느낀다\n최근에 책을 통해 사기를 당하면, 비가역적인 손상을 입을 수 있고,\n그 처벌 또한 시원하게 할 수 없는 경우가 잦다는 것을 알게 되었다\n왜냐면, 우리의 도덕과 법이 완전히 일치하지 않기 때문이다\n그런데, 그런 위험을 이겨내고 살아남아서 우리 가족을 지켜내셨고, 삶을 포기하지 않으셨다\n또, 어렸을 때부터 귀에 못이 박히도록,\n슬리퍼 신지 말고, 옷과 머리는 단정히 깔끔하게 다녀야 한다\n진짜 매일 말씀하셨는데, 이젠 그 말이 이해가 된다.\n아무렴 그 반대의 것을 잔뜩 누리면서 살았지만야\n분명히 드레스 코드는 많은 것을 드러내는 지표로 사용 되기 때문에\n단정하고, 깔끔한 외관이 여러모로 도움이 될 상황이 많은거 같다. 전략적으로 사용 될 수 있다\n사업하시는 아빠 입장에서 드레스 코드가 내포하는 의미가 무엇인지 알고 있기 때문에 그러셨겠군 싶다\n항상 강조하시는 사람을 만나면 무조건 인사 잘해야 한다.\n처음 보면 안녕하세요, 그 날 여러번 마주치면 싱긋 웃으면서 목례를 하라했던 것도 이해가 된다\n이해가 되는 요즘이다, 단순한 문장 뒤에 숨은 복잡한 백그라운드가 있음을 느낀다\n기회가 되면, 그 이야기를 들어보고 싶다아"},"음향-엔지니어가-JavaScript의-실행-메커니즘-이해하는-방법":{"title":"음향 엔지니어가 JavaScript의 실행 메커니즘 이해하는 방법","links":[],"tags":["음향","Technology","Programming","Music"],"content":"JavaScript의 실행 메커니즘 이해하기 - 사운드 엔지니어를 위한 안내서\nJavaScript는 싱글 스레드 언어로, 동기와 비동기 코드를 효율적으로 처리하기 위해 콜 스택, 이벤트 루프, 그리고 태스크 큐를 사용합니다. 이 글에서는 사운드 엔지니어의 작업 흐름을 비유로 들어 JavaScript의 실행 메커니즘을 쉽게 이해할 수 있도록 설명하겠습니다.\n콜 스택(Call Stack)\n🎛️ 믹싱 콘솔의 현재 작업 채널\n콜 스택은 현재 실행 중인 함수들이 쌓이는 공간입니다. 이는 마치 사운드 엔지니어가 믹싱 콘솔에서 특정 채널을 조작하는 것과 같습니다. 엔지니어는 한 번에 하나의 채널에 집중하여 EQ 조정, 이펙트 적용 등의 작업을 수행합니다. 작업이 완료되면 다음 채널로 넘어가죠.\n예를 들어, 보컬 트랙의 EQ를 조정하는 동안에는 다른 트랙을 건드리지 않습니다. 이처럼 콜 스택은 현재 처리 중인 작업의 순서를 관리하며, 상위에 있는 작업이 완료되면 그 아래의 작업을 이어서 처리합니다.\n이벤트 루프(Event Loop)\n🔄 작업 스케줄러의 역할\n이벤트 루프는 콜 스택과 태스크 큐를 관리하여 비동기 작업이 언제 실행될지 결정하는 역할을 합니다. 이는 사운드 엔지니어의 어시스턴트가 작업 스케줄을 관리하며, 엔지니어가 현재 작업을 마치면 다음에 어떤 작업을 해야 할지 알려주는 것과 비슷합니다.\n어시스턴트는 긴급한 작업과 일반 작업을 구분하여 우선순위를 정합니다. 긴급한 수정 사항이 있으면 즉시 엔지니어에게 알리고, 일반적인 작업은 예정된 순서에 따라 안내합니다. 이벤트 루프도 이와 같이 마이크로태스크와 매크로태스크를 구분하여 처리합니다.\n태스크 큐(Task Queue)\n📋 작업 대기 목록\n태스크 큐는 비동기 작업의 콜백 함수들이 대기하는 곳입니다. 이는 엔지니어가 앞으로 처리해야 할 작업 목록과 같습니다. 태스크 큐는 우선순위에 따라 마이크로태스크 큐와 매크로태스크 큐로 나뉩니다.\n마이크로태스크 큐(Microtask Queue)\n마이크로태스크 큐는 긴급하게 처리해야 하는 작은 작업들이 대기하는 곳입니다. 예를 들어, 믹싱 중에 발견된 작은 노이즈 제거나 즉각적인 페이드 인/아웃 작업이 여기에 해당합니다. 이러한 작업은 우선적으로 처리되어야 하므로 이벤트 루프는 마이크로태스크 큐를 먼저 확인합니다.\n매크로태스크 큐(Macro Task Queue)\n매크로태스크 큐는 일반적인 작업들이 대기하는 곳입니다. 예를 들어, 기타 트랙에 리버브를 적용하거나 드럼 트랙의 컴프레서를 조정하는 등의 예정된 작업이 여기에 포함됩니다. 마이크로태스크가 모두 처리된 후에야 매크로태스크가 실행됩니다.\n음향 예시로 보는 JavaScript 실행 흐름\n🎚️ 믹싱 콘솔에서의 작업 (JavaScript 런타임 환경)\n당신은 대형 믹싱 콘솔 앞에 앉아 있습니다. 이 콘솔이 바로 JavaScript 런타임 환경입니다.\n1. 메인 트랙 작업 시작 (전역 실행 컨텍스트 생성)\n믹싱 세션을 시작하면서 메인 페이더를 조정합니다. (JavaScript 코드 실행이 시작되고 전역 실행 컨텍스트가 생성되어 콜 스택에 푸시됩니다.)\n2. 보컬 EQ 조정 (함수 호출)\n보컬 채널의 EQ를 조정하기 위해 해당 섹션으로 이동합니다. (함수가 호출되면 새로운 실행 컨텍스트가 생성되어 콜 스택에 푸시됩니다.)\nfunction adjustVocalEQ() {\n    // EQ 조정 로직\n}\nadjustVocalEQ();\n3. 비동기 작업 요청 (비동기 API 호출)\nEQ를 조정하면서 동시에 어시스턴트에게 “기타에 리버브 추가”와 “노이즈 제거” 작업을 요청합니다. (비동기 함수들이 호출되고, Web API에 작업이 등록됩니다.)\nsetTimeout(() =&gt; addReverbToGuitar(), 0); // 매크로태스크\nPromise.resolve().then(() =&gt; removeNoise()); // 마이크로태스크\n4. 보컬 EQ 조정 완료 (함수 실행 완료)\n보컬 EQ 조정을 마치고 해당 채널에서 손을 뗍니다. (함수 실행이 완료되고 해당 실행 컨텍스트가 콜 스택에서 제거됩니다.)\n5. 어시스턴트의 작업 확인 (이벤트 루프 동작)\n잠시 콘솔에서 손을 떼고 어시스턴트를 바라봅니다. 어시스턴트는 요청받은 작업들의 우선순위를 확인하고 있습니다. (이벤트 루프가 콜 스택이 비었는지 확인하고, 태스크 큐를 검사합니다.)\n6. 긴급 노이즈 제거 작업 (마이크로태스크 실행)\n어시스턴트가 “노이즈 제거 작업이 긴급합니다!”라고 알려줍니다. 즉시 노이즈 제거 작업을 수행합니다. (마이크로태스크 큐의 작업이 콜 스택으로 이동하여 실행됩니다.)\nfunction removeNoise() {\n    // 노이즈 제거 로직\n}\n7. 기타 리버브 추가 (매크로태스크 실행)\n노이즈 제거 후, 어시스턴트가 “이제 기타에 리버브를 추가할 차례입니다”라고 안내합니다. 기타 채널로 이동하여 리버브를 추가합니다. (매크로태스크 큐의 작업이 콜 스택으로 이동하여 실행됩니다.)\nfunction addReverbToGuitar() {\n    // 리버브 추가 로직\n}\n8. 새로운 작업 확인 (이벤트 루프 반복)\n리버브 추가를 마치고 다시 어시스턴트를 바라봅니다. 새로운 작업이 있는지 확인합니다. (이벤트 루프가 다시 태스크 큐를 확인하며 새로운 작업이 있는지 검사합니다.)\n🔄 반복 과정\n이러한 과정이 계속 반복되면서 모든 믹싱 작업이 순차적으로, 그리고 효율적으로 처리됩니다. (JavaScript 런타임은 이벤트 루프를 통해 비동기 작업들을 관리하며 싱글 스레드에서 동시성을 구현합니다.)\n이 과정을 통해 복잡한 믹싱 작업(JavaScript 프로그램)이 체계적으로 진행되며, 긴급한 작업(마이크로태스크)과 일반 작업(매크로태스크)이 적절히 처리되는 것을 볼 수 있습니다.\n💻 코드 예시와 비교\nconsole.log(&#039;보컬 트랙 EQ 조정 시작&#039;); // 동기 작업\n \nsetTimeout(() =&gt; {\n  console.log(&#039;기타 트랙 리버브 적용&#039;); // 매크로태스크\n}, 0);\n \nPromise.resolve().then(() =&gt; {\n  console.log(&#039;노이즈 제거&#039;); // 마이크로태스크\n});\n \nconsole.log(&#039;보컬 트랙 EQ 조정 완료&#039;); // 동기 작업\n출력 결과:\n보컬 트랙 EQ 조정 시작\n보컬 트랙 EQ 조정 완료\n노이즈 제거\n기타 트랙 리버브 적용\n\n\n동기 작업: ‘보컬 트랙 EQ 조정 시작’과 ‘보컬 트랙 EQ 조정 완료’는 즉시 실행됩니다.\n마이크로태스크: ‘노이즈 제거’는 긴급한 작업으로, 동기 작업이 완료된 후 바로 실행됩니다.\n매크로태스크: ‘기타 트랙 리버브 적용’은 예정된 작업으로, 마이크로태스크가 모두 처리된 후 실행됩니다.\n\n정리\nJavaScript의 실행 메커니즘은 사운드 엔지니어의 작업 흐름과 유사합니다.\n\n콜 스택은 현재 집중하여 처리하는 작업입니다.\n이벤트 루프는 작업의 순서를 관리하여 다음에 어떤 작업을 처리할지 결정합니다.\n태스크 큐는 대기 중인 작업들의 목록이며, 우선순위에 따라 마이크로태스크와 매크로태스크로 나뉩니다.\n\n마이크로태스크: 즉각적으로 처리해야 하는 긴급한 작업들입니다.\n매크로태스크: 예정된 일반 작업들입니다.\n\n\n"},"음향-엔지니어가-Javascript-Concurrency-Vs-Parallelism-이해하는-방법":{"title":"음향 엔지니어가 Javascript Concurrency Vs Parallelism 이해하는 방법","links":[],"tags":["ComptuerScience/동시성","병렬성","JavaScript"],"content":"동시성 (Concurrency)\n동시성은 여러 작업이 논리적으로 동시에 진행되는 것을 의미합니다. JavaScript에서는 단일 스레드로 동작하지만, 이벤트 루프를 통해 동시성을 구현합니다.\n비유: 믹싱 콘솔에서의 여러 트랙 관리\n라이브 공연 중 사운드 엔지니어는 믹싱 콘솔을 통해 여러 악기와 보컬의 소리를 조절합니다. 하지만 두 손으로 한 번에 하나의 노브(knob)나 페이더(fader)만 조작할 수 있습니다. 그럼에도 불구하고 빠르게 여러 컨트롤을 번갈아 가며 조작하여 전체적인 사운드를 조화롭게 유지합니다.\n\n여기서 사운드 엔지니어가 여러 트랙을 관리하는 것은 JavaScript의 동시성에 해당합니다.\n각각의 노브 조작은 단일 스레드의 작업이고, 이를 빠르게 번갈아 가며 조작하는 것은 비동기 작업 처리입니다.\n\n이벤트 루프\n\n이벤트 루프(Event Loop) 는 JavaScript에서 비동기 작업을 관리하는 메커니즘입니다.\n이는 사운드 엔지니어가 대기 중인 여러 사운드 조정 요청을 순서대로 처리하는 것과 비슷합니다.\n긴급한 조정은 우선 처리하고, 나머지는 차례로 처리하여 공연의 흐름을 매끄럽게 유지합니다.\n\n예시 코드:\nconsole.log(&quot;공연 시작&quot;);\n \nsetTimeout(() =&gt; console.log(&quot;리버브 적용&quot;), 0);\nsetTimeout(() =&gt; console.log(&quot;디스토션 적용&quot;), 0);\n \nPromise.resolve().then(() =&gt; console.log(&quot;볼륨 조정 1&quot;));\nPromise.resolve().then(() =&gt; console.log(&quot;볼륨 조정 2&quot;));\n \nconsole.log(&quot;공연 진행 중&quot;);\n실행 결과:\n공연 시작\n공연 진행 중\n볼륨 조정 1\n볼륨 조정 2\n리버브 적용\n디스토션 적용\n\n설명:\n\n볼륨 조정(Promise) 은 즉각적으로 필요한 작업이므로 먼저 처리됩니다.\n이펙트 적용(setTimeout) 은 조금 뒤에 처리해도 되므로 나중에 실행됩니다.\n이는 사운드 엔지니어가 긴급한 볼륨 조정을 먼저 하고, 이후에 이펙트 적용을 수행하는 것과 같습니다.\n\n\n병렬성 (Parallelism)\n병렬성은 여러 작업이 물리적으로 동시에 진행되는 것을 의미합니다. JavaScript에서는 Web Workers를 통해 제한적인 병렬 처리가 가능합니다.\n비유: 메인 엔지니어와 어시스턴트의 협업\n대형 공연에서 사운드 엔지니어는 모든 작업을 혼자 처리하기 어렵기 때문에 어시스턴트 엔지니어와 함께 작업합니다.\n\n메인 엔지니어는 전체 믹스를 관리하고, 어시스턴트 엔지니어는 특정 악기의 이펙트나 모니터링을 담당합니다.\n두 엔지니어는 동시에 작업하며, 필요한 경우 서로 통신하여 공연의 음향을 최적화합니다.\n\n여기서:\n\n메인 엔지니어는 메인 스레드에 해당합니다.\n어시스턴트 엔지니어는 Web Worker에 해당합니다.\n서로 독립적으로 작업하지만, **메시지(통신)**를 통해 협업합니다.\n\nWeb Workers의 작동 방식\n\nWeb Worker는 메인 스레드와 분리된 실행 환경에서 동작하는 스레드입니다.\nCPU 집약적인 작업을 별도로 처리하여 메인 스레드의 응답성을 유지합니다.\n메시지 전달을 통해 메인 스레드와 데이터를 주고받습니다.\n\n예시 코드:\nmain.js\nconsole.log(&quot;메인 엔지니어 작업 시작&quot;);\n \nconst worker = new Worker(&#039;worker.js&#039;);\n \nworker.onmessage = function(event) {\n  console.log(&#039;어시스턴트로부터 받은 결과:&#039;, event.data);\n};\n \nworker.postMessage(&#039;이펙트 처리 요청&#039;);\n \nconsole.log(&quot;메인 엔지니어 작업 계속 진행&quot;);\nworker.js\nself.onmessage = function(event) {\n  console.log(&#039;어시스턴트가 받은 메시지:&#039;, event.data);\n  // 복잡한 이펙트 처리 시뮬레이션\n  const result = &#039;이펙트 처리 완료&#039;;\n  self.postMessage(result);\n};\n실행 결과:\n메인 엔지니어 작업 시작\n메인 엔지니어 작업 계속 진행\n어시스턴트가 받은 메시지: 이펙트 처리 요청\n어시스턴트로부터 받은 결과: 이펙트 처리 완료\n\n설명:\n\n메인 엔지니어는 자신의 작업을 계속하면서 어시스턴트에게 특정 작업을 맡깁니다.\n어시스턴트 엔지니어는 받은 요청을 처리하고 결과를 메인 엔지니어에게 전달합니다.\n이를 통해 동시에 여러 작업이 진행되어 공연의 품질을 높입니다.\n\n\n정리\n\n\n동시성 (Concurrency)\n\nJavaScript의 이벤트 루프를 통한 비동기 작업 처리\n사운드 엔지니어가 여러 트랙을 빠르게 조절하여 동시에 진행되는 것처럼 보이게 함\n단일 스레드에서 여러 작업을 효율적으로 관리\n\n\n\n병렬성 (Parallelism)\n\nWeb Workers를 통한 제한적인 병렬 처리\n어시스턴트 엔지니어와 메인 엔지니어가 동시에 작업을 수행\nCPU 집약적인 작업을 메인 스레드의 방해 없이 처리 가능\n\n\n"},"조테로-(Zotero)":{"title":"조테로 (Zotero)","links":["Zotero-7-hookmark-동작-안하는-것-해결-방법"],"tags":["논문관리","참고문헌관리","인용관리","학술연구","연구도구","CitationManagement","AcademicResearch","BibliographyManagement","ResearchTools","terminology"],"content":"조테로 (Zotero)\nWhat is Zotero\n\n정의 (Definition):\n\n조테로는 연구자들이 소스를 관리하고 조직할 수 있게 도와주는 무료, 오픈 소스 참고문헌 관리 도구입니다. 사용자가 연구 자료를 수집, 정리, 인용, 공유할 수 있게 지원합니다(Center for History and New Media, 2022).\n이 도구는 연구논문 작성 시 필요한 인용문을 자동으로 생성해주고, 사용자의 라이브러리를 동기화하여 여러 장치에서 접근할 수 있게 합니다(Roy Rosenzweig Center for History and New Media, 2021).\n\n\n예시 (Examples):\n\n연구자가 논문을 작성하면서 조테로를 사용하여 참고문헌을 관리하고, 필요한 인용 스타일로 서식을 적용할 수 있습니다.\n학생이나 교수가 공동 연구 프로젝트에 참여할 때 조테로의 그룹 기능을 사용하여 자료를 공유하고 협업할 수 있습니다.\n\n\n\nPlugin\n\nMohamedElashri/awesome-zotero: A curated list of awesome Zotero resources\n\nZotero &amp;&amp; Hookmark\n\nZotero 7 hookmark 동작 안하는 것 해결 방법\n\nTranslate for Zotero\n\nwindingwind/zotero-pdf-translate: Translate PDF, EPub, webpage, metadata, annotations, notes to the target language. Support 20+ translate services.\n\nZotero is a research support tool. I recommend the Zotero plugin for translating academic articles. This plugin allows customization of settings such as auto-translation selection, auto-translation annotations, and views.\nAuto-translation selection: When a phrase is selected, it is automatically translated and the translated phrase is displayed in a pop-up.\nAuto-translation annotations: When annotations are made on a phrase, the plugin either adds the translated phrase or changes the annotations to their translated version.\nBy utilizing these features, researchers can streamline their workflow and improve the efficiency of their academic research process."},"크램폴린-IDE---NGINX-문제-해결":{"title":"크램폴린 IDE - NGINX 문제 해결","links":["🔥-Programmer","🏷️-Develop-Notes","Nginx","00.-Inbox/Notion/Campus-life/카카오-테크-캠퍼스/카카오-테크-캠퍼스","Projects/카카오테크캠퍼스/카카오-테크-캠퍼스","축팅","⚙️-Kubernetes"],"tags":["대외활동/카카오테크캠퍼스","개발/환경/에러","포스트","개발"],"content":"persona :: 🔥 Programmer\nindex :: 🏷️ Develop Notes\n#개발\n크램폴린 IDE - Nginx 문제 해결\n2023년은 카카오 테크 캠퍼스에서 교육을 받았습니다\n오늘은 카카오의 클라우드 기반 학습 관리 시스템인 크램폴린 환경에 배포하며 겪은 문제를 나누려고 합니다\nIntro. 무슨 일인가\n카카오 테크 캠퍼스 3단계 프로젝트의 주제는 축팅(네 컷 사진을 통해 축제에서 자연스러운 만남을 주선하는 서비스)이었습니다\n사진 업로드 기능을 배포 환경에서 테스트하니, Nginx 413 Request Entity Too Large 에러가 발생하였습니다\n찾아보니 기본 body size가 1M인 것을 해제하면 되는거라 금방 다시 배포를 하였습니다\n하지만,,, 문제는 해결 되지 않았죠\n\n\nNginx 413 에러란?\n\n의미 : 요청 엔티티의 크기가 너무 크다\n파일 용량이 너무 커서 디스크가 가득 차 사이트가 다운 되는 것을 방지하기 위해 설정되어있다\n\n\n\n\n원인 파악\n\n원인을 파악하기 위해서 크램폴린 배포 플로우를 다시 상기 할 필요가 있었습니다\n왜냐하면, 크램폴린 IDE에서 배포는 쿠버네티스 환경에서 진행 되기 때문입니다\nKargo를 사용하여 DKOS 클러스터에 애플리케이션을 배포하는 것을 보면 알 수 있죠\n\n\nKargo\n\n쿠버네티스 클러스터에 애플리케이션을 배포하는 도구\n지금은 Kubespray로 프로젝트 이름이 변경 되었다고 한다\n\n\n\n\n1. 쿠버네티스 환경에서 Nginx 설정이 잘못 되었는가?\n쿠버네티스 환경에서 Nginx 설정을 할 수 있는 경로는 2가지입니다\n\n인그레스 컨트롤러(ingress controller) 설정\n\nNGINX 인그레스 컨트롤러에서 어노테이션(annotation)을 통해 Nginx 설정을 적용\n\n\nNGINX 설정 커스터마이징:\n\nNGINX의 설정 파일인 nginx.conf를 직접 수정한 Pod을 생성\n\n\n\n인그레스 컨트롤러(ingress controller) 설정 조절\n쿠버네티스의 인그레스 컨트롤러는 외부 요청을 클러스터 내부 서비스로 라우팅하는 역할을 합니다.\n먼저 카카오 크램폴린에서 기본으로 제공하는 Nginx 를 사용하고, 기존의 제가 설정한 관련 Pod들을 제거하였습니다\n그 후 body size를 조정하였습니다\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: example-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/proxy-body-size: &quot;64m&quot;\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /example-path\n        pathType: Prefix\n        backend:\n          service:\n            name: example-service\n            port:\n              number: 80\n하지만,, 여전히 문제는 해결 되지 않았습니다\n2. NGINX 설정 커스터마이징\nNGINX 설정을 직접 수정하는 경우, nginx.conf 파일을 수정하여 Pod에 적용할 수 있습니다\nhttp {\n    …\n \n    client_max_body_size 64M;\n \n    …\n}\nConfigMap으로 설정을 주입하고, 직접 Nginx 이미지 패키징 할 때 설정 파일을 넣어 봤지만 여전히 문제는 해결 되지 않았습니다\n2. 로그 확인 : Hint 발견\nNginx Pod을 띄우고, 1M 이하의 이미지는 받아지지만, 용량을 초과하는 경우에 Postman에 에러를 뱉고 있으니, 이미지 크기 제한 문제가 확실했습니다\nPod 로그를 확인해보니, 다른 API 엔드 포인트에 대한 요청은 로그로 남고 있는데 413 에러가 누락 되는 것을 확인하였습니다\nNginx Pod에 사용 된 이미지의 경우, 바디 사이즈만 조절 되었기 때문에 로그가 누락 될리가 없는데 수상했습니다\nNginx 기본 Docker 이미지를 사용했다면, Nginx 에러 로그가 기록 되어야 하기 때문입니다\n왜냐하면, Nginx 이미지의 기본 로그 레벨은 error이고, 413 에러는 기본 error 레벨에서 기록 되어야하기 때문이죠\n먼가 제가 구성한 인프라의 문제가 아닐거라는 의심이 들었습니다\n3. 로컬에서 동일한 환경 구성 후 테스트\n의심되는 이미지(바디 사이즈 조절 된 기본 Nginx 이미지)를 로컬에서 테스해보았습니다\n\n재현 방법\n\n기존의 NGINX 이미지 생성 후 로컬 BE 프로젝트에 연결\n80881로 NGINX 연결하고, Postman으로 큰 이미지 전송\nNGINX 통과 후 BE 프로젝트 예외 반환 확인!\n\n\n\n\n큰 이미지가 결국 Nginx 이미지를 통과했으니, 제가 만든 이미지의 문제가 아닌거죠\n해결\n결론적으로 쿠버네티스 환경 관리자 분께 문의 드렸습니다\n확인 결과 저희 서비스 앞 단의 크램폴린에서 설정한 Nginx 문제라 판단이 되었습니다\n\n그 결과 문제 해결!\n이미지 퀄리티가 중요한 서비스에서 1M가 제한은 치명적이었고,\n팀 내에서 제가 배포를 맡고 있었어서 제 파트 문제라 스트레스를 많이 받았습니다\n이미지 제한 문제 해결하며 개발 일정이 밀리기도 했구요\n그래도 해결하니까 매우 뿌듯했습니다\n\n깨달은 점\n\n인프라 등 당연한 것들도 합리적인 의심을 할 필요가 있다\n협업 상황에서는 문제 진행 상황 공유와 적절한 시기에 시니어에게 도움을 요청하자\n\n될 때까지 잡고 늘어지다 개발 일정 밀리는 것은 일을 잘한다 할 수 없다\n\n\n\n\n\n\n  \n  \n\nTMI\n그리고, 저희 팀 카카오 테크 캠퍼스 3단계 우수조로 뽑혔습니다 올 한해 제일 짜릿한 순간이었어요\n\n궁금했던 점\nproxy_body_size와 client_max_body_size의 차이\nclient_max_body_size와 proxy_body_size는 NGINX 설정에서 비슷한 역할을 하지만, 적용되는 컨텍스트(context)에 따라 다릅니다\n\n\nclient_max_body_size:\n\n이 설정은 클라이언트로부터 직접 받은 요청의 본문 크기를 제한합니다.\nNGINX가 직접적으로 클라이언트의 요청을 처리할 때 사용됩니다.\n예를 들어, 클라이언트가 서버에 파일을 업로드하는 경우, client_max_body_size는 업로드할 수 있는 파일의 최대 크기를 제한합니다.\n\n\n\nproxy_body_size (어노테이션: nginx.ingress.kubernetes.io/proxy-body-size):\n\n이 설정은 NGINX가 프록시 서버로 동작할 때, 업스트림 서버로 전송되는 요청 본문의 크기를 제한합니다.\n주로 인그레스 컨트롤러와 같이 NGINX가 프록시 역할을 하는 경우에 사용됩니다.\n예를 들어, 인그레스 컨트롤러를 통해 내부 서비스로 요청을 전달하는 경우, 이 설정은 프록시를 통해 전달되는 요청 본문의 최대 크기를 제한합니다.\n\n\n\n결론\n\n\n직접 운영하는 NGINX 서버의 경우\n\nclient_max_body_size를 nginx.conf 파일에서 설정합니다. 이는 NGINX가 클라이언트로부터 직접 요청을 받을 때 적용됩니다.\n\n\n\n쿠버네티스 인그레스 컨트롤러 사용 시\n\nnginx.ingress.kubernetes.io/proxy-body-size 어노테이션을 사용하여 proxy_body_size를 설정합니다.\n이는 인그레스 컨트롤러를 통해 들어오는 요청에 대해 적용됩니다.\n\n\n"}}